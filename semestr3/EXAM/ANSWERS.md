# Список вопросов к экзамену по ЭВМ, мехмат, 3 семестр, 2020.
## Вопросы по курсу "Алгоритмы и алгоритмические языки".

1.    Что такое дополнительный код?  

для представления отрицательного числа берется представление его модуля, все биты инвертируются, к результату прибавляется 1

2.    Какое отношение  кольцо вычетов имеет к дополнительному коду?  

Представление чисел в дополнительном коде эквивалентно представлению чисел в кольце вычетов по модулю 2^n, где n – количество бит в двоичном представлении числа.
Для доказательства утверждения достаточно доказать, что вышеприведенное определение отрицательного числа в дополнительном коде эквивалентно следующему: пусть x>0, то -x получается с помощью операции 2n-x. В исходном определении число -x получается из x>0 следующим образом: сначала производится инверсия числа, что эквивалентно операции 2^n-x-1. Это следует из того, что (2^n-x-1)+x=2^n-1=числу, состоящему из n единиц, а это возможно только если на месте единичных бит числа 2n-x-1 стоят нули в представлении числа x и наоборот (на  месте нулевых бит числа 2^n-x-1 стоят единицы в представлении числа x). Осталось прибавить 1 и мы получим требуемые 2^n-x.

3.    Каков алгоритм деления на 2 для целого числа в дополнительном коде на уровне бит?  

x = p * 2^dmin
где  p – число с фиксированной точкой в виде x.xxxxx (где x – двоичная цифра; хранятся все указанные биты!).
число 2^-150 уже неотличимо от 0.Если вышеуказанные число получались каждый раз путем деления предыдущего числа на 2, то в результате получения последнего число из 2^-149 мы получили ситуацию underflow – нижнее переполнение.

4.    Какие преимущества у дополнительного кода представления целых чисел по сравнению с прямым кодом?  

Он позволяет заменить операцию вычитания на операцию сложения и сделать операции сложения и вычитания одинаковыми для знаковых и беззнаковых чисел, чем упрощает архитектуру ЭВМ. 

5.    В чем преимущество вещественных чисел с фиксированной точкой над вещественными числами с плавающей точкой?  

Достоинство такой формы – простота и наглядность представления чисел и алгоритмов реализации операций.

6.    В чем преимущество вещественных чисел с плавающей точкой над вещественными числами с фиксированной точкой?  

Относительно большой диапазон представления величин, который проявляется при необходимости представления слишком больших или малых чисел, т.е. точку можно перемещать по разрядной сетке с целью уменьшения или увеличения дробной или целой части вещественного числа.

7.    Что означает фраза "одно вещественное число с плавающей точкой много меньше другого"?  

Проблема сравнения чисел с плавающей точкой на равенство заключается в том, что многие числа не имеют точного представления в двоичной с плавающей запятой. Если сравниваются достаточно далекие числа - с разницей >> машинного эпсилон, то фраза имеет смысл.

8.    Могут ли натуральные числа от 1 до миллиона точно представляться в виде вещественного числа типа float? Ответ обосновать.  

да. вопрос об индексации массива float'ом. Миллион - это примерно 2^20. float представляется в виде 4 байт = 32 разряда, сл. хватит точности для миллиона натуральных.

9.    Определение машинного эпсилон.  

Числовое значение, меньше которого невозможно задавать относительную точность для любого алгоритма, возвращающего вещественные числа. Абсолютное значение «машинного эпсилон» зависит от разрядности сетки применяемой ЭВМ, типа (разрядности) используемых при расчетах чисел, и от принятой в конкретном трансляторе структуры представления вещественных чисел (количества бит, отводимых на мантиссу и на порядок). Формально машинный эпсилон обычно определяют как минимальное из чисел ε, для которого 1+ε>1 при машинных расчетах с числами данного типа.

10.   С какой точностью представляется вещественное число в виде вещественного числа с плавающей точкой (если оно не слишком большое)?  

точность float: от 6 до 9 цифр (в основном 7);  
точность double: от 15 до 18 цифр (в основном 16);  
точность long double: 15, 18 или 33 цифры (в зависимости от того, сколько байт занимает тип данных на компьютере).

11.   На основе каких постулатов строится тип NUMBER (Oracle)?  

Число в таком формате может занимать различное количество байт, поэтому во внутреннем представлении числа сначала хранится байт с длиной числа в байтах, а потом само число. Далее разберем формат хранения самого числа.  
Ноль хранится в виде одного байта 0x80.  

Для хранения любого другого числа x оно представляется в виде x=s*y*100^n, где s=1 или -1, 1≤y<100 называется мантиссой, n – целая степень числа. Все незначащие нули в конце y отбрасываются. Например: 1234.56=1*12.3456*1001, 1000. =1*10. *1001. Если количество цифр до/после точки нечетное, то дополним цифры нулем до/после числа. Например: 234.5=1*02.3450*1001. Будем далее работать с этим нормализованным представлением числа.  
В начале представления числа хранится байт со степенью в виде: если х положительно, то байт имеет вид  n+65+128=n+0x41+0x80= (n+0x41)|0x80=n+0xC1 т.е. берется n+65 и в старший бит прописывается 1. Если х отрицательно, то делается все то же самое, но потом число еще инвертируется. Т.о. старший бит первого байта числа будет хранить знак числа: если бит = 1, то число положительно, иначе – отрицательно.  

Отметим, что нулевая степень для положительного числа хранится как 65+128=193=1100 0001b, а для отрицательно – как ~1100 0001b=0011 1110b=62, и от этих чисел (193 и 62) можно вести отсчет при расчете внутреннего представления степени.

12.   Как правильно выписать условие на языке С, что у квадратного уравнения существует единственное решение?  

if(!((b*b)-4*a*c>0)&&!((b*b)-4*a*c>0)) ...  
а еще лучше через введенное eps (разное для разных машин):  
if(abs((b*b)-4*a*c)<eps)...

13.   По каким формулам следует вычислять на языке С корни квадратного уравнения в случае наличия двух корней?  

(не забыть проверку коэфф-ов)  
x1=(-b+sqrt(D))/(2*a);  
x2=(-b-sqrt(D))/(2*a);
  
14.   Определение абсолютной ошибки вещественного числа. Теорема о распространении абсолютной ошибки при арифметических операциях.  

Назовем абсолютной ошибкой приближения числа x0 с помощью числа x такое  D, что  
| x - x0| < D.  
Т. При сложении/вычитании чисел их абсолютные ошибки складываются.  

15.   Определение относительной ошибки вещественного числа. Теорема о распространении относительной ошибки при арифметических операциях.  

Назовем относительной ошибкой приближения числа x0 с помощью числа x такое  d, что  
| x - x0| / | x0 | < d   
Т. При умножении/делении чисел их относительные ошибки складываются (с точностью до пренебрежимо малых членов).  

16.   Связь машинного эпсилон и абсолютной/относительной ошибок представления вещественных чисел с плавающей точкой.  

e  представляет собой абсолютную ошибку представления числа 1. e также является и относительной погрешностью представления числа 1 в ЭВМ.  
Теорема. Любое вещественное число x в стандартном представлении числа с плавающей точкой (т.е. не являющееся слишком большим или слишком маленьким по модулю в вышеописанном смысле) имеет относительную ошибку представления порядка e (точнее, не более, чем вдвое отличающуюся от e) и имеет абсолютную ошибку представления порядка x * e (точнее, не более, чем вдвое отличающуюся от x * e).  

17.   Почему вещественные числа с плавающей точкой могут самопроизвольно меняться в программе?  

Компьютер не может хранить все цифры числа, он хранит только несколько первых значащих цифр. остальное может заполняться "мусором".  

18.   Почему нельзя сравнивать на равенство вещественные числа с плавающей точкой?  

Компьютер не может хранить все цифры числа, он хранит только несколько первых значащих цифр.  
Последние разряды могут иметь любые значения, поэтому вещественные числа надо сравнивать с помощью введенного параметра Epsilon.  

19.   Основные свойства понятия алгоритм?  

Алгоритмом m называется формально описанная процедура, имеющая некоторый набор входных данных In(m) и выходных данных Out(m). Вводится некоторый параметр, оценивающий объем входных данных N=N(In(m)).  Будем называть этот параметр размером входных данных.  
При создании алгоритма закрепляется некоторый конечный  набор допустимых операций, в терминах которых формулируется алгоритм. От алгоритма требуется его конечность, т.е. мы говорим, что задача решается с помощью некоторого алгоритма, только если для каждого набора входных данных соответствующий набор выходных данных получается с помощью заданного алгоритма за конечное количество допустимых операций.  

20.   Что такое время работы алгоритма?  

Для оценки времени работы алгоритма с каждой допустимой операцией ассоциируется время ее выполнения. Временем выполнения реализации алгоритма T(m) для определенных начальных данных называется сумма времен выполнения всех операций алгоритма при выполнении данной реализации.  

21.   Что значит задача a сводится к задаче b за время O(f(n))? 

//(В лекциях использовалось время g(N), которое заменил на O(f(n)))  
Будем говорить, что задача z1 сводится к задаче z2 за время O(f(n)), если  
	+входные данные задачи z1, имеющие объем N, могут быть приведены к входным данным задачи z2, при этом входные данные задачи z2 тоже имеют объем N;  
	+выходные данные задачи z2 могут быть приведены к выходным данным задачи z1,  
        +и все это за суммарное время O(f(n)) (т.е. суммарное время выполнения алгоритмов приведения = O(f(n))).  


22.   Что такое верхняя оценка времени работы алгоритма?  

Верхней оценкой времени выполнения алгоритма m называется такая функция F(N), что для любого набора входных данных In(m) размером не более N время выполнения алгоритма не будет превосходить F (N).  

23.   Что такое верхняя оценка времени решения задачи?  

 Будем говорить, что задача z имеет верхнюю оценку времени решения F (N), если существует алгоритм m с верхней оценкой времени выполнения F (N).  

24.   Что такое нижняя оценка времени работы алгоритма?  

Нижней оценкой времени выполнения алгоритма m  называется такая функция j(N), что для любого N найдется такой набор входных данных алгоритма размером N, что время работы данного алгоритма на указанных данных будет не меньше j(N).  

25.   Что такое нижняя оценка времени решения задачи?  

Нижней оценкой времени решения задачи z  называется такая функция j(N), что для любого алгоритма, решающего данную задачу,  j(N) будет нижней оценкой времени работы данного алгоритма.  

26.   Теорема о взаимосвязи нижних оценок времен решения задач при сведении задач. Формулировка. Идея доказательства.  

Если задача z1 сводится к задаче z2 за время g(N) и задача z2 имеет верхнюю оценку времени решения F2(N), то задача z1  имеет верхнюю оценку времени решения F1(N) = F2(N) + g(N).  
(*Доказательство теоремы тривиально.*)  

27.   Теорема о взаимосвязи верхних оценок времен решения задач при сведении задач. Формулировка. Доказательство.  

Если задача z1 сводится к задаче z2 за время g(N) и задача z1 имеет нижнюю оценку времени решения j1(N), то задача z2  имеет нижнюю оценку времени решения j2(N) = j1(N) - g(N).  
Доказательство. Выпишем аккуратно условие того, что j2(N) является нижней оценкой времени решения задачи z2:  
Для любого алгоритма m2 :  j2(N) -  нижняя оценка времени работы алгоритма m2.  
или:  
Для любого алгоритма m2 и для любого N>0 сущ. In(m2) с размером, равным N:  T(m2 (In(m2)))≥j2(N)  = j1(N) - g(N).  
Поведем доказательство от противного. Допустим это не так, т.е. выполняется условие:  
Сущ. алгоритм m2 и N>0: для люб. In(m2) :  T(m2 (In(m2)))<j2(N)  = j1(N) - g(N).  
Тогда существует алгоритм (заключающийся в сведении задачи m1 к задаче m2 за время g(N)), для которого на всех исходных данных размера N задача решается за время, меньшее j1(N) - g(N)+ g(N)= j1(N) , что противоречит условию теоремы.  

28.   Определение сортировки. Условия существования сортировки.  

Пусть дано некоторое упорядоченное подмножество (последовательность) элементов из P : {a1, …, aN}, ai принадлежат P. Требуется найти такую перестановку (x1,…,xN), что ax1, …, axN – будет неубывающей последовательностью, т.е. axi < ax(i+1) или axi = ax(i+1)   
Сортировкой называется искомая перестановка.  

29.   Теорема о существовании и единственности сортировки.  

Доказательство существования сортировки проводится по индукции по n  
Доказательство единственности:  
можно сначала показать, что в упорядоченном множестве элементы, между которыми выполняется соотношение = должны идти подряд, что дает возможность заменить их одним элементом. Далее можно ввести функцию M(i) – количество элементов из {a1, …, aN}, меньших ai. Отметим, что для любых i≠j  выполняется: M(i)≠M(j) (действительно: выполняется либо ai < aj, либо ai > aj, откуда легко вывести, что, соответственно, M(i)<M(j) , либо M(i)>M(j)), из чего сразу вытекает (учитывая, что 0≤M(i)<n), что функция M(i) принимает все возможные значения от 0 до n-1. Легко показать, что эта функция однозначно определяет положение элемента ai в упорядоченном множестве.  

30.   Сколько операторов сравнения надо определить, чтобы реализовать сортировку?  

Достаточно определить 1 оператор "меньше" a<b. При этом "больше" определеляется по симметрии b<a. "Равенство" определяется как не "больше" и не "меньше"  

31.   Сортировка пузырьком. Случай оптимальности сортировки пузырьком.  

Алгоритм:  
N-1 раз выполняется следующая процедура:  
    Для всех i  от 1 до N-1 c шагом 1:  
        если a[x[i]] > a[x[i+1]]   то поменять местами a[x[i]] и a[x[i+1]]  
Алгоритм требует порядка O(n * n) арифметических операций.  
Теорема. Алгоритм сортировки пузырьком является оптимальным по порядку времени выполнения среди алгоритмов, основанных на операции сравнения, если обмен местами двух элементов последовательности требует O(N) времени.  
Доказательство. Рассмотрим следующую последовательность:  
N, N-1, N-2, … 2, 1
Для любой сортировки этой последовательности следует первый в ней элемент поставить на последнее место (=порядка O(N-1) операций), второй элемент поставить на предпоследнее место (=порядка O(N-2) операций) и т.д. Итого, только перестановки займут не менее O(N*N) времени, откуда мы получаем нижнюю оценку времени выполнения алгоритмов данного класса. Данная оценка достигается на предложенном алгоритме.  
 
32.   Теорема о верхней оценке времени работы алгоритма сортировки пузырьком в случае когда время обмена местами двух элементов=Θ(|i-j|).  

Теорема. Пусть время сравнения элементов последовательности = 0, пусть время обмена местами двух элементов с индексами i,j =Θ(|i-j|),  
то сущ нижняя оценка времени решения задачи сортировки = Θ(n * n)., где n = количество элементов в последовательности  
Доказательство. Рассмотрим следующую последовательность:  
N, N-2,N-3, … 2, 1  
T >= Θ(|n-1|)+Θ(|n-3|)=...=Θ(n * n)  

33.   Определения сортировки, основанной на сравнениях.  

Будем говорить, что алгоритм сортировки основан на операциях сравнения, если алгоритм может быть записан в виде бинарного дерева (дерева решения), каждая вершина которого либо является завершающей (т.е. при попадании в нее исходная последовательность данных оказывается отсортированной), либо:  
вычисляется некоторая функция от входных данных алгоритма,  
производится сравнение полученной величины с 0 (одной из операций: <, > или =)  
от каждой вершины дерева, в зависимости от полученного результата, происходит переход к левой или правой ветви дерева  
на каждой ветви дерева происходит одна определенная для данной ветви транспозиция элементов входных данных (обмен местами двух определенных элементов последовательности).  

34.   Чему соответствует одно ребро в дереве решений для задачи сортировки?  

Одно ребро в дереве решения соответствует одной замене элементов последовательности местами (одной транспозиции)  

35.   Чему соответствует одна вершина в дереве решений для задачи сортировки?  

Одна вершина в дереве решений есть положение последовательности (возможно уже несколько изменной, мб и не до конца),  
В каждой такой вершине вычисляется функциия (например, которая ищет необходимость транспозиции), и результат сравнивается с 0  
В зависимости от результата сравнения выбирается правое или левое ребро (или не выбирается, если последовательность отсортирована)  

36.   Сколько конечных вершин (листьев) у дерева решений для задачи сортировки? В каком случае?  

Количество завершающих вершин = n!  
Д-во. Исключим из этого дерева все ветки, начиная с элемента, в который нельзя попасть и до завершающего элемента дерева. Удаление данных веток никак не повлияет на реальный алгоритм.  
Теперь каждой перестановке s(1,…,N) соответствует своя концевая вершина в дереве решения (соответствующая только этой перестановке), такая что ветка дерева решения от корня до данной вершины задает перестановку p, обратную s.: p(s(i))=i "iÎ{1,…,N}.  Т.е. данная ветка задает решение задачи сортировки для последовательности исходных данных {s(1), s(2,)… s(N)}.  

Действительно, в силу определения дерева решений, для каждой последовательности исходных данных {s(1), s(2,)… s(N)} мы имеем ровно одну ветвь дерева решений (от корня до завершающей дерево вершины), сортирующую данную последовательность. Причем, каждая завершающая дерево вершина является концевой ровно для одной перестановки s(1,…,N). Действительно, мы исключили вершины, до которых нельзя в принципе добраться, поэтому осталось исключить ситуацию, когда вершина соответствует сразу двум различным перестановкам s(1,…,N) и r(1,…,N). Но в последнем случае мы имеем: p(s(i))=i и p(r(i))=i "iÎ{1,…,N}, где перестановка p описана выше. Из чего сразу получаем, что перестановки s и r совпадают.  
Таким образом, мы доказали, что количество завершающих вершин дерева решений равно количеству перестановок множества {1,…,N}, равно n!. 

37.   Формулировка теоремы о верхней оценке времени решения задачи сортировки, основанной на сравнениях.  

Существует алгоритм слияния с рекурсией, имеющий верхнюю оценку времени работы O(n * log2(n))  
Он основан на сравнениях, поэтому его верхняя оценка переносится на задачу сортировки, основанной на сравнениях.  

38.   Формулировка теоремы о нижней оценке времени решения задачи сортировки, основанной на сравнениях. 

(В этом вопросе важна точность формулировки)  
Существует нижняя оценка времени решения задачи сортировки, основанной на сравнениях, равная Θ(n * log2(n))  
То есть  
Для любого алгоритма решения задачи сортировки и для любого n, существует набор входных данных размером n , такой что время работы этого алогритма на этих входных данных больше или равно чем const*n*log2(n)  

39.   Можно ли построить сортировку, основанную на сравнениях, которая для любого N будет работать в каких-то случаях быстрее, чем за время O(n log n)?  

Да, можно. Для этого построим алгоритм, который сначала проверяет упорядочена ли последовательность с самого начала. Это происходит за линейное временя (O(n)).  
После начинается сама сортировка. Тогда для набора данных, где последовательность отсортирована изначально, наш алгоритм будет работать за линейное время, то есть быстрее  

40.   Привести пример алгоритмов, которые не укладываются в схему алгоритма на основе дерева решения.  

Цифровая сортировка (*см 54 вопрос*)  

41.   Идея алгоритма сортировки слиянием с рекурсией.  

Алгоритм:  
Если в массиве меньше или равно 1 элемента ВЫХОД  
Массив делится на 2 половины  
Для первой половины вызывается данный алгоритм  
Для второй половины вызывается данный алгоритм  
Слить первую и вторую половину во временный массив  
Скопировть временный массив в исходный  
Алгоритм слияния: (условный)  
В временный массив взять наименьший из очередного элемента первого и очередного элемента второго  

42.   Идея алгоритма сортировки слиянием без рекурсии.  

Слить 2 массива длиной 1 (состоящего из первого и второго элемента)  
Далее слить все такие пары длиной 1  
Получится массивы длиной 2, внутри отсортированные, теперь сливать уже их  
4, 8,...  и тд  
Заметим, что последние пары массивов могут получиться неравной длины, их следует сливать обычным образом  
Отличие заключается в условном порядке  

43.   Сколько и какой дополнительной памяти требует алгоритм слиянием с рекурсией? 

(Одинаково как с так и без рекурсии)  
Алгортим сортировки слиянием тебует дополнительной памяти Θ(n) в куче(медленной памяти) для временных массивов и Θ(log2(n)) памяти в стеке (быстрой) для рекурсионного вызова функций ( log2(n) как максимальная глубина рекурсии)  

44.   Сколько и какой дополнительной памяти требует алгоритм слиянием без рекурсии? 

(Одинаково как с так и без рекурсии)  
Алгортим сортировки слиянием тебует дополнительной памяти Θ(n) в куче(медленной памяти) для временных массивов и Θ(log2(n)) памяти в стеке (быстрой) для рекурсионного вызова функций ( log2(n) как максимальная глубина рекурсии)  

45.   Теорема об оптимальности алгоритма слияния двух упорядоченных массивов.  

Пусть даны два упорядоченных множества {A1,…,AN } и {B1,…,BN }.  
В рамках алгоритмов, основанных на простых сравнениях, данные множества нельзя слить быстрее, чем за 2N-1 сравнение в худшем случае. Т.е. 2N-1 является нижней оценкой времени работы алгоритма, если учитывать только время, расходуемой на сравнения элементов множеств, и если положить время одного сравнения равным 1.  

46.   Общее описание алгоритма QSort.(*Press F*)  

Выбирается псевдомедиана - какой-то элемент массива  
Происходит движение индекса от начала массива к концу пока текущий элемент меньше псевдомедианы  
Аналогично движение другого индекса от конца к началу пока текущий элемент больше псевдомедианы  
После выполнения данной процедуры меняем элементы, на которых остановились  
Далее индексы сдвигаются первый к концу, второй к началу (*те согласно их ходу движения*)  
Процедура выше повторяется пока индексы не встретятся  
В итоге мы получаем 3 (2) части массива  
Тот, что меньше псевдомедианы  
Псевдомедиана (ее можно не выделять поэтому можно сказать, что массив разбит на 2 части)  
Больше псевдомедианы  
Для оставшихся неотсортированными 2 частей массива выполняем данную процедуру


47.   Теорема о среднем времени работы алгоритма QSort.(*PRESS F*)  

Среднее время работы (среднее арифметическое) алгоритма QSort на массиве из N различных элементов = O(n * log2(n)). Под средним временем подразумевается среднее время по всем перестановкам любого массива входных данных длины N, состоящего из различных элементов.

Данная теорема объясняет, в каком смысле данный алгоритм является оптимальным. В то же время, в реальной жизни, часто поток входных данных не является случайным, поэтому в качестве медианы следует брать случайно выбранный элемент.

48.   Алгоритм HeapSort.  

Скажем, что массив пирамидально-упорядоченный, если  
a[i]>=a[2i+1] и a[i]>=a[2i+2]  
Тогда массив можно представить в виде бинарного дерева (но не дерева поиска)  
Где в корне 0-ой элемент, его потомки это 1 и 2 элемент, потомки 1-ого элемента это 3 и 4 и тд   
Тогда по построению первый элемент наибольший в массиве, кладем его в конец  
Структура после удаления корня изменяется, тогда необходимо вновь сделать массив пирамидально-упорядоченный
(*Необходимо предъявить функцию постороения такого массива, что описано далее, но возможно хватит и верхнего*)  
Процедура Heapify:  
Проверяем i, 2i+1, 2i+2 элемент,  
Если i меньше чем хотя бы 1 из остальных, то меняем i и максимальный из оставшихся  
Далее применяем эту процедуру для j=2i+1 или 2i+2 (в зависимости от того, кто больше)  
(*Далее в принципе уже ответ на другой вопрос - 49*)  
Максимальная глубина рекурсии при этом равна высоте дерева, те log2(n)  
Вызывается это процедура n раз, начиная в массиве с его конца  
Время работы алгоритма HeapSort равно O(n log2(n)) 

49.   Теорема об оценке времени работы алгоритма HeapSort.  

Время работы алгоритма HeapSort равно O(n log2(n)).  На самом деле, оказывается, что время работы первого из двух циклов алгоритма равно O(N). Действительно, процедура Heapify(A,i)  для каждого i из последнего уровня дерева выполняется за время O(1) (а в этом уровне содержится половина всех элементов!). Для следующего уровня время выполнения процедуры равно уже O(2). И т.д. 

50.   Определение и основные свойства объекта куча (пирамида) из алгоритма HeapSort.  

Кучей будем называть такое дерево, что каждый элемент (точнее его значение) этого больше чем его потомки.  
Очевидным свойством является то, что корень данного дерева, больше всех других элементов.  

51.   Теорема о времени работы алгоритма построения пирамиды.  

Пирамида строится за время O(log2(n)) (*как максимальный уровень погружения*)

52.   Определение устойчивой сортировки.  

Устойчивая сортировка = сортировка, не меняющая порядка равных элементов  

53.   Сортировка подсчетом.

Пусть мы хотим отсортировать N целых чисел A={A1,…, AN}, каждое из которых не превосходит K, при этом K=O(N).  
Тогда мы можем создать временный массив B размером K, в который можно поместить для каждого i  количество чисел в массиве A, не превосходящих i.  
Тогда для каждого 1 <= i <= N: в отсортированном массиве в элементе с индексом B[A[i]]  лежит элемент, равный A[i].  

54.   Цифровая сортировка.  

Пусть требуется отсортировать массив целых чисел, записанных в некоторой позиционной системе исчисления. Сначала мы сортируем массив устойчивым методом (*см 52*) по младшей цифре.  
Потом – по второй, и т.д. Очередная сортировка не меняет порядок уже отсортированных элементов, поэтому в конце мы получим отсортированный массив. 
Прямой проверкой доказывается следующая теорема.  
Алгоритм цифровой сортировки требует O(nd) операций, где n – максимальное количество операций для одной внутренней сортировки, d – количество цифр. 
Этот алгоритм облегчает использование сортировки подсчетом. Действительно, если есть большой массив 32-битных целых чисел без приемлемых ограничений на их величину,  
то можно разбить их на 2 либо 4 части и рассмотреть каждую часть как одну цифру в алгоритме цифровой сортировки.  

55.   Для каких данных применима сортировка подсчетом?  

Если мы хотим отсортировать N целых чисел A={A1,…, AN}, каждое из которых не превосходит K, при этом K=O(N)  

56.   Для каких данных применима цифровая сортировка?  

Если требуется отсортировать массив целых чисел, записанных в некоторой позиционной системе исчисления  

57.   Сколько дополнительной памяти требует сортировка подсчетом?  

Сортировка подсчетом требует дополнительной памяти равной O(n) (*на временный массив*)  

58.   Сколько дополнительной памяти требует цифровая сортировка? 

(*явного ответа в лекциях не нашел, из соображений логики*)  
Цифровая сортировка использует другие устойчивые сортировки, в нашей реализации сортировку подсчетом  
Следовательно она требует также дополнительной памяти равной O(n)  

59.   Определение выпуклой оболочки.  

Множество точек S на плоскости называется выпуклой оболочкой множества точек {A1 ,…, AN } на плоскости, если S является наименьшим выпуклым множеством, содержащим точки {A1 ,…, AN }.  

60.   Алгоритм Грэхема построения выпуклой оболочки.  

Алгоритм Грэхема:  
Выбирается точка гарантированно лежащая в этой оболочке  
(Например, как в лекциях, это точка пересечения медиан произвольного треугольника  
Или точка с максимумом или минимумом по какой-то коородинате)  
После выбирается какая-то прямая, прохоядящая через выбранную точку  
И отсчитываются все углы между заданной прямой и построенной по выбранной и любой другой точкой.  
После точки сортируются по значению угла  
Выбирается точка с самым большим (или меньшим) углом, при этом, если несколько точек имеют этот угол выбираются именно самая дальняя от выбранной  
Эти две точки - начало нашей выпуклой оболочки
Далее считается угол (с помощью векторного произведения например) между последовательно выбранными точками  
Если этот угол больше 180 градусов, последняя точка удаляется из выпуклой оболчки и сравнивается угол между предыдущей гранью и новой при этом точки удаляются пока угол не станет меньше 180  
(Он станет меньше в какой-то момент, так как по построению все точки лежат по одну сторону от первых 2 в выпуклой оболочке)  
После проверки и возможного удалания очередная точка добавляяется  
(Есть определение с сайта если мое объяснение непонятно, но оно не сильно приятнее)  
http://lectures.stargeo.ru/alg22/algorithms.htm#_Toc9059834  

61.   Теоремы о верхней оценке решения задачи построения выпуклой оболочки в R2 в рамках алгоритмов, основанных на сравнениях.  

Верхняя оценка решения задачи построения выпуклой оболочки в R2 в рамках алгоритмов, основанных на сравнениях, равна O(n * log2(n))  
Алгортим Грэхема имеет такую оценку, он основан на сортировке по углу. Следовательно, оценка работы алгоритма Грэхема переносится  

62.   Теоремы о нижней оценке решения задачи построения выпуклой оболочки в R2 в рамках алгоритмов, основанных на сравнениях.  

Нижняя оценка решения задачи построения выпуклой оболочки в R2 в рамках алгоритмов, основанных на сравнениях, равна O(n * log2(n))  
Для доказательство теоремы докажем, что задача сортировки сводится к задаче нахождения выпуклой оболочки за время O(n).  
Рассмотрим множества вещественных чисел {x1 ,…, xN }. На числовой плоскости построим множество точек {(x1 , x1 *  x1), (x2 , x2 * x2)…, (xn , xn * xn) }. Т.е. каждой точке xi сопоставим точку на стандартной параболе (xi , xi * xi).  
Для построенного множества точек решим задачу построения выпуклой оболочки. Найдем точку (xi , xi * xi) с минимальным значением xi.  
Последовательный перебор вершин построенного многоугольника даст набор точек с отсортированными значениями xj.  

63.   Определение диаграммы Вороного.  

Рассмотрим множество точек {A1 ,…, AN } на плоскости.  
Диаграммой Вороного называется разбиение плоскости на множества {P1 ,…, PN}, где Pi состоит из точек, более близких к Ai,  
чем к остальным точкам из множества {A1 ,…, AN }. Будем называть Ai центром области Pi.

64.   Теорема о существовании диаграммы Вороного.

(*По построению?*)  
Для двух точек A1 и A2 диаграммой Вороного будет разбиение плоскости на две полуплоскости прямой, являющейся серединным перпендикуляром к [A1 , A2]. 
В общем случае (для произвольного конечного множества {A1 ,…, AN } ) Pi представляет собой пересечение полуплоскостей,  
образованных серединным перпендикуляром ко всем отрезкам [Ai , Aj ] (i≠j), содержащих Ai.  

65.   Определение триангуляции Делоне.  

Триангуляцией Делоне множества точек {A1 ,…, AN } называется такая триангуляция множества точек {A1 ,…, AN },  
что для любого треугольника триангуляции T описанная вокруг него окружность не содержит внутри никаких точек из множества {A1 ,…, AN}.  
(*Триангуляцией по заданному набору точек {A1 ,…, AN } называется разбиение выпуклой оболочки множества точек {A1 ,…, AN }*  
 *на непересекающиеся по внутренности треугольники таким образом, чтобы множество вершин треугольников совпадало бы с множеством точек {A1 ,…, AN }.*)  
 
66.   Связь диаграммы Вороного и триангуляции Делоне.  

Рассмотрим множество треугольников, образованных тройками точек из {A1 ,…, AN }, являющимися центрами многоугольников Вороного,  
имеющими одну общую вершину. Данное множество треугольников дает триангуляцию выпуклой оболочки множества точек {A1 ,…, AN}  

67.   Поиск порядковой статистики за линейное время в среднем.

(*Алгоритм основан на QiuckSort*)
Определение. k-той порядковой статистикой множества из N вещественных чисел A={A1,…, AN} называется k-тое число в упорядоченном множестве A.  
Среднее время работы алгоритма QFindStatP равно Θ(N), где N – количество элементов в обрабатываемом массиве.  
Под средним временем подразумевается среднее время по всем перестановкам любого массива (*то есть среднее арифметическое*),  
состоящего из различных элементов входных данных длины N.  
QFindStatP (A,p,q,k)  
Если  q-p < 1 то return A[p]  
Вечный цикл  
   i=p; j=q;  
   Поменять местами A[p] и случайно выбранный элемент A[l] , где p <= l <= q  
   x=A[i]  
   Пока A[i] < x:i++;  
   Пока A[j] > x:j--;  
   Если  i < j то  
      поменять местами A[i] и A[j];  
   иначе  
     {Если k <= j  
       то return QFindStatP (A,p,j,k)  
       иначе return QFindStatP (A,j+1,q,k)  
     }
   i++;j--;  
Конец вечного цикла

68.   Идея поиска порядковой статистики за линейное время в худшем случае.  

Зададимся целью написать алгоритм нахождения k-ой порядковой статистики, требующий Θ(N) операций в худшем случае.  
Это было бы возможным, если бы в алгоритме QFindStatP на каждом этапе разбиения множества на две части мы бы получали части размером не менее sL,  
где L – длина разбиваемой части множества, s<1. Для этой цели мы построим алгоритм QFindStat5,  
который перед разбиением множества на две части разбивает его на пятерки последовательных элементов,  
в каждой пятерке ищет медиану и на полученном множестве медиан пятерок чисел запускает самого себя для поиска медианы полученного множества.  
Полученную медиану медиан x алгоритм использует для разбиения множества на две части, состоящих, соответственно, из элементов меньше или равных x,  
и из элементов больше или равных x. Далее, в зависимости от k, следует применить QFindStat5 к одной из полученных половин множества.

69.   Поиск порядковой статистики последовательности целых чисел {ai} (i=1,…,n) за линейное время для случая ai < O(n). Основные идеи.  

Итак, пусть есть массив целых чисел {Ai} (i=0,…,N-1), 0<=A[i]<M. Требуется вычислить порядковую статистику с номером q.  
Для работы алгоритма требуется дополнительный массив целых чисел B длины M. Алгоритм аналогичен сортировке подсчетом:
QFindStatD (A,N, q, B,M):  
Для всех i от 0 до M-1 с шагом 1 выполнить: B[i]=0  
Для всех i от 0 до N-1 с шагом 1 выполнить: B[A[i]]++  
Для всех i от 0 до M-1 с шагом 1 выполнить: ЕСЛИ q<B[i] то ВЕРНУТЬ i  ИНАЧЕ q-=B[i]  
Теорема. O(N+M) является верхней оценкой времени работы алгоритма  QFindStatD  для случая 0<=Ai<M, где N – количество элементов в обрабатываемом массиве. Для случая M=O(N) верхней оценкой времени работы алгоритма является O(N).

70.   Задача поиска порядковой статистики в большой окрестности каждой точки серого изображения.  

Обычно под серым изображением имеется в виду массив целых чисел A[i][j] размером Nx×Ny со значениями 0<=A[i]<=255.  
Требуется для всех I,J найти порядковую статистику с номером q для множества пикселов с индексами I-M <= i <= I+M, J-M <= j <= J+M.
Для решения данной задачи модифицируем алгоритм QFindStatD следующим образом. Будем перебирать индексы пикселов, в окрестности которых считается медиана, по строкам.
Для I=0 медиана будет считаться с помощью алгоритма QFindStatD.  
Далее в цикле по I при расчете медианы для окрестности пиксела I,J отметим, что в рассматриваемое множество пикселов будут добавляться точки с i=I+M  
(кроме M последних столбцов) и удаляться точки с i=I-M (кроме M первых столбцов).  
Тогда, если мы будем хранить в процессе вычислений массив B из алгоритма QFindStatD, то для каждого I,J его модификация потребует всего лишь O(M) операций.  
Здесь, конечно, следует отметить, что в оценку времени работы алгоритма войдет количество градаций яркости изображения (у нас = 256),  
но для больших M (у нас больше 100) это замечание несущественно.
Таким образом, мы получили алгоритм решения данной задачи с верхней оценку времени работы = O(Nx×Ny×M),  
т.е. среднее время вычисления порядковой статистики в данном случае для каждой области равно квадратному корню от количества точек в рассматриваемой области.  

71.   Регулярные выражения в UNIX. Простые примеры использования.

(*http://lectures.stargeo.ru/themes/bash.htm*)  
Регулярные выражения используются для поиска и замены кусков текста в bash, например в  
потоковых редакторах awk, sed, grep, egrep, sort. Примеры:  
Заменить расширения файлов `cpp’ на расширение `P’:  
for i in *.cpp; do mv $i `echo $i|sed ’s/^(.).cpp$/1.P/’`  
Встроенная сортировка по сравнению с полем 2:  
ls -l | sort --key=2  
Чтобы исключить имена папок, попавшие в поток вывода ls:  
ls -l |grep -v '/'  

72.   bash: Что такое локальные и импортируемые переменные?  

Локальные имеют область видимости внутри своей функции(блока). Не требуют $ в подстановке.  
Глобальные - во всей программе(скрипте, системе) - например, их можно задать в .bashrc)  
пример глобальной:  
var="hello"  
function foo(){ echo $var }  
foo #выведет hello   
пример локальной:  
function foo() {local var; var="hello"; echo var}  
foo #выведет hello  
echo $var #ничего не выведет  

73.   bash: Синтаксис цикла for  

Обычный:  
for planet in Меркурий Венера Земля Марс Юпитер Сатурн Уран Нептун Плутон  
do  
  echo $planet  
done  
С-подобный:  
for ((a=1; a <= 10 ; a++))  # Двойные круглые скобки 
do
  echo -n "$a "
done  

74.   bash: примеры вычисления арифметических выражений.  

// using let  
let a=5+4  
echo $a        # 9  
let a++  
echo $a        # 10   
let "a = $1 + 30"  
echo $a        # 30 + первый аргумент командной строки  
// using expr  
expr 11 % 2 #5  
// using (())  
a=$(( 4 + 5 ))  
echo $a # 9  

75.   bash: примеры вычисления логических выражений.  

Битовые операции:  
    << - сдвигает на 1 бит влево (умножение на 2);  
    >> - сдвиг вправо на 1 бит (деление на 2);  
    & - по-битовое И (AND);  
    | - по-битовое ИЛИ (OR);  
    ~ - по-битовая инверсия;  
    ! - По-битовое отрицание;  
    ^ - по-битовое исключающее или (XOR);  
    ^= - по-битовое исключающее-или-равно;  
пример:  
let a = ~(4<<6) || (3|1) && !(2)  

76.    Понятия палитры, битовых плоскостей, true color в изображениях.

В заголовочном файле bmp.h для работы с BMP обычно описывают следующие переменные  
структуры BITMAP: bmPlanes и bmBitsPixel.
bmPlanes - Количество плоскостей в битовом изображении. В зависимости от типа видеоадаптера и его режима работы для представления цвета одного пиксела может использоваться несколько бит, расположенных в одной или нескольких плоскостях видеопамяти  
bmBitsPixel - Количество битов, используемых для представления цвета пиксела. Если используется несколько плоскостей, то это поле содержит количество бит одной плоскости, используемых для представления цвета пиксела. 

Формат true color - когда каждый пиксел задается 4-мя байтами. Из них используется 3 байта для размещения RGB компонент цвета (по одному байту на каждую компоненту).


77.   Основные идеи формата изображения BMP.  

Обычно формат не использует алгоритмов сжатия.  
Данный формат дает возможность представлять изображения с палитрой или без нее. При наличии палитры значение цвета в каждом пикселе задается номером цвета. Сам цвет определяется по его номеру в палитре, представляющей собой массив  
unsigned char pal[256][4];  
Каждая строка в массиве палитры задает один цвет с помощью указания его RGB составляющих, соответственно, в ячейках с номерами 0, 1, 2. Количество строк зависит от количества используемых цветов и, обычно, не превосходит 256 (что соответствует изображению, в котором на один пиксел отводится 8 бит).  
Данные можно представлять в формате true color, когда каждый пиксел задается 4-мя байтами. Из них используется 3 байта для размещения RGB компонент цвета (по одному байту на каждую компоненту).  
Возможно большое количество нестандартных вариаций данного формата. Например, отсутствие палитры в изображениях с толщиной 8 бит на пиксел может обозначать, что кодируется серое изображение, в каждом байте которого хранится яркость пиксела.  
Файл состоит из следующих разделов:  
·         Заголовка  
·         Возможно – палитры  
·         Собственно данных  

78.   C++. Понятия инкапсуляции и полиморфизма.  

Инкапсуляция - это способность языка вмещать все, что отностится к объекту, описываемемое языком, внутри одного программного объекта  
Внутри структуры мы можем описать, все что с ним свзязано  
В языке C++ внутрь объекта могут помещаться не только другие объекты, но и функции(методы), которые можно поменять к этому объекту.  
Полиморфизм - это возможность внутри программы создавать насколько функций с одинаковым именем  
При этом различаются они своими параметрами  

79.   C++. Понятия простых и сложных классов. 

(*не нашел строгое более определение*)
Гласное отличие сложного класса от простого - это необходимость правильно управлять памятью  
При создании переменной этого класса, возмножно потребуется выделить память (например какой-то массив),  
При этом важно очистить память при смерти этой переменной  
В простом классе такая необходимость отсутсвует, так как инициализация не требует отведения памяти,  
Поэтому для него не требуется деструктор, так как при смерти объекта вызываются стандартые деструкторы  

80.   С++. Чем отличаются структуры от классов?  

Основное отличие структуры и класса - это возможность создавать приватные и публичные поля  
Только в классе можно создавать эти поля  
Приватное поле задается как private:  
и доступ ко всем объектам далее(переменным или методам например) имеют только объекты, описываемые внутри этого же класса  
(или объекты другого класса, объявленного как дружественный для этого класса)  
Публичное public:  
к объектам внути этого поля имеется доступ и снаружи этого класса  
При создании класса поле по умолчанию считается приватным  

81.   Статические элементы структур/классов. Синтаксис.

Статический элемент - это некий аналог глобальной переменной. Его инициализация и уничтожение происходит независимо от класса  
То есть статический элемент сохраняет свое значение вне зависимости от самого класса, членом которого он является  
При этом он стирается только при завершении всей программы  
Для создания статического элемента необходимо прописать перед ним слово static  
Для инициализации (вне класса) надо прописать его тип, класс:: название...  
Class B{  
/**/  
Static A a;  
}  
ClassA B::a;  

82.   C++. Конструкторы. Синтаксис. Вызов для подобъектов.  

Конструктор отвечает за инициализацию внутренних переменных при создании объекта.  
Он есть всегда и по умолчанию ничего не инициализирует  
При этом (так как есть полиморфизм) можно создать несколько конструкторов. Все конструкторы описываются как функция без возращаемого типа  
То есть   
class ClassName{   
ClassName(){/*...*/} конструктор по умолчанию (он всегда без входных параметров)  
ClassName(class AnotherClass x,...){/*...*/}  еще один конструктор  
}  

83.   C++. Деструкторы. Синтаксис.  Вызов для подобъектов.  

Деструктор отвечает за "смерть объекта"  
Он очищает память использованную при создании объекта  
Вызывается он также автоматически при необходимости (во время завершения функции, например)  
Его также можно модифицировать.  
Синтаксисически он вызывается аналогично конструктору только перед названием класса добавляется ~  

84.   С++. Почему присваивание по умолчанию нельзя использовать в сложных классах?  

Конструктор копирования по умолчанию это побайтовое копирование одного объекта в другого.  
При этом оператор присваивания вызывается только тогда, когда уже существует объект, который необходимо изменить.  
То есть в нем уже выделена память, определены переменные.  
Но при этом побайтовое копирование может неправильно сработать (например часть памяти отведенной изначально не очистится)  
Тогда для этого необходимо сначала очистить объект, которому мы присваиванием новое значение  

85.   С++. Зачем нужен конструктор копирования? (Странный вопрос имхо)  

Конструктор копирования нужен для создания копии данного объекта. Если при присваивании есть возможность того, что какие-то данные уже инициализированны, то в нашем случае этого нет  
(*см 93 для непонятного примера*)  

86.   C++. Переопределение бинарных операторов. Синтаксис.  

(*бинарный оператор - оператор в 2 аргументами*)  
ClassName{  
ClassName operator+(const ClassName &x){...}  
}  
Данный оператор вызывается как a+b, что эквивалентно a.operator+(b)  

87.   C++. Переопределение унарных операторов. Синтаксис.  

(*унарный оператор - оператор с 1 аргументом*)
(*По сути переопределение (перегрузка) работает так же, как при для унарного*)
ClassName{  
ClassName operator!(){...}  
}  
Данный оператор вызывается как !a, что эквивалентно a.operator!  

88.   C++. Переопределение операторов преобразования типа. Синтаксис.  

(*Оператор преобразования типа унарный*)
ClassName{  
operator sometypename * (){return x}, где x имеет тип sometypename  
}  
Данный оператор вызывается как !a, что эквивалентно a.operator!  

89.   C++. Какие операторы не могут переопределяться как глобальные функции?  

(*Ответ с Хабра, в лекциях не нашел*)  
Некоторые операторы в не перегружаются в принципе.  
В С++ отсутствует оператор возведения в степень (как в Fortran) "**".  
Запрещено определять свои операторы (возможны проблемы с определением приоритетов).  
(*Этих операторов не было в лекциях*)  
Оператор выбора члена класса ".".  
Оператор разыменования указателя на член класса ".*"  

90.   C++. Оператор запятая. Использование.  

(*Опять же не найдено в лекциях поэтому ссылка и часть текста оттуда*)
*https://docs.microsoft.com/ru-ru/cpp/cpp/comma-operator?view=msvc-160*
Позволяет группировать два оператора, когда ожидается один.  
Оператор-запятая имеет ассоциативность слева направо. Два выражения, разделенные запятой, вычисляются в направлении слева направо. Левый операнд вычисляется всегда и перед вычислением правого операнда учитываются все побочные эффекты.  
В некоторых контекстах, например в списках аргументов функций, в качестве разделителей можно использовать запятые. Не следует путать использование запятой в качестве разделителя с ее использованием в качестве оператора; эти два варианта использования совершенно различны.  

91.   C++. Примеры сложных неявных преобразований типов.  

unsigned short Hash( void *p ) {  
   unsigned int val = reinterpret_cast<unsigned int>( p );  
   return ( unsigned short )( val ^ (val >> 16));  
}

92.   C++. Отведение памяти.  

Аналогом функций типа malloc, free в языке являются операторы new и delete  
int *v;  
v=new int[10]; - отведение памяти под массив 10 целых чисел  
delete[] v; - очищение памяти  

93.   C++. Конструкторы копирования. Примеры использования. 

(*см 85*)
a=b+c  
(*В конце примеры скопированные из задач, мб поможет*)
CComplexVector &operator=(const CComplexVector &rhs){if(this!=&rhs){Clean();CopyOnly(rhs);} return *this;}  
void CopyOnly(const CComplexVector &rhs){if(this!=&rhs){v=new ComplexNumber[n=rhs.n];memcpy(v,rhs.v,n*sizeof(ComplexNumber));}}  
void Clean(){delete[] v; SetZero();}    

CComplexVector &operator=(CComplexVector &&rhs){if(this!=&rhs){delete v; n=rhs.n;v=rhs.v;rhs.SetZero();} return *this;}  
void CopyOnly(const ComplexNumber *rhs, const int &n){this->n=n;memcpy(v=new ComplexNumber[this->n],rhs,(n)*sizeof(ComplexNumber));}

94.   C++. Параметры по умолчанию. Синтаксис.

void printValues(int a, int b=5)  
{  
    std::cout << "a: " << a << '\n';  
    std::cout << "b: " << b << '\n';  
}
 
int main()  
{  
    printValues(1); // в качестве b будет использоваться значение по умолчанию - 5  
    printValues(6, 7); // в качестве b будет использоваться значение, предоставляемое пользователем - 7  
}

95.   C++. Исключения.

try //код, который может привести к ошибке, располагается тут  
        {  
            if (num2 == 0){throw 123; }//генерировать целое число 123  
            cout << "answer" << endl;   
        }  
catch(int i)//сюда передастся число 123  
        {cout << "Ошибка №" << i << " !" << endl;}

96.   С++. SEH-исключения Microsoft.

Существует два механизма SEH.
    Обработчики исключений или try...__ except блоки, которые могут реагировать на исключение или закрыть его.  
    Обработчики завершения или try...__ finally блоки, которые вызываются всегда, если исключение вызывает завершение или нет.  

Эти два типа обработчиков различаются, но тесно связаны с процессом, называемым очисткой стека. При возникновении структурированного исключения Windows ищет недавно установленный обработчик исключений, который сейчас является активным. Обработчик может выполнить одно из трех действий:  
   не распознать исключение и передать управление другим обработчикам;  
   распознать исключение, но отбросить его;  
   распознать исключение и обработать его.

97.   C++. Возможность продолжения работы программы при выбросе исключения с места выброса исключения.  

Компилируем программу с ключом -g и проверяем на gdb :)  
Есть еще способы. При отладке кода можно указать отладчику не прерывать выполнение при возникновении исключений, которые не обрабатываются в пользовательском коде, но обрабатываются в другом месте. Ну и конечно, исключения надо обрабатывать, чтоб программа не завершалась после выброса.  
Пример - мои проги по ЭВМ, в районе task1, тесты в main.cpp.

98.   С++. Дружественные функции/классы. Примеры. 

Дружественная функция — это функция, которая имеет доступ к закрытым членам класса, как если бы она сама была членом этого класса. Во всех других отношениях дружественная функция является обычной функцией. Ею может быть, как обычная функция, так и метод другого класса. Для объявления дружественной функции используется ключевое слово friend перед прототипом функции, которую вы хотите сделать дружественной классу. Неважно, объявляете ли вы её в public- или в private-зоне класса. Например:  
class Anything
{  
private:   
    int m_value;  
public:  
    Anything() { m_value = 0; }   
    void add(int value) { m_value += value; }  
    // Делаем функцию reset() дружественной классу Anything  
    friend void reset(Anything &anything);  
};  
void reset(Anything &anything)
{ anything.m_value = 0;}

99.   C++. Ввод/вывод на экран. Общий синтаксис.

Библиотека iostream определяет три стандартных потока:  
    cin  стандартный входной поток (stdin в С)  
    cout  стандартный выходной поток (stdout в С)  
    cerr  стандартный поток вывода сообщений об ошибках (stderr в С)  
Для их использования в Microsoft Visual Studio необходимо прописать строку:  
using namespace std;

100.    C++. Ввод/вывод на экран. Манипуляторы.

Ввод/вывод на экран/с экрана в С++ осуществляется с помощью операторов cin и cout соответственно, а значит  манипуляторы форматирования используются совместно с данными операторами ввода/вывода. Различие между функциями флагами и манипуляторами форматирования состоит в способе их применения. Теперь рассмотрим способы применения объектов форматирования.
	
//Основные форматирующие функции-члены:
cout.fill('/*symbol*/');     // устанавливает символ заполнитель  
cout.width(/*width_field*/); // задает ширину поля  

Флагов очень много: boolalpha true oct dec hexshowbase uppercase showpos scientific fixed right left  
Манипулятры есть такие же, + endl, и используются с другим синтаксисом: cout << oct << 64 << endl;

101.    С++. move-конструкторы. Примеры использования.  

Используются в операторе = т.к после них не надо очищать память:  
// Move constructor.
MemoryBlock(MemoryBlock&& other) noexcept : _data(nullptr), _length(0)
{  
   _data = other._data;  
   _length = other._length;  
   other._data = nullptr;  
   other._length = 0;  
}

102.    С++. move-присваивание. Примеры использования.  

// Move assignment operator.  
MemoryBlock& operator=(MemoryBlock&& other) noexcept  
{  
   if (this != &other)  
   {  
      delete[] _data;  
      _data = other._data;  
      _length = other._length;  
      other._data = nullptr;  
      other._length = 0;  
   }  
   return *this;  
}

103.    С++. casts.

Чаще всего используют static_cast, dynamic_cast, reinterpret_cast, const_cast.  
double res = static_cast<double>(13)/7; когда типы нормально преобразуются  
type *subСlass = dynamic_cast<type *>( objPtr ); когда преобразуются указатели или классы  
const char *string = "Sevastopol"; function(const_cast<char *>(string)); когда надо преобразовать константный указатель на символьную строку в неконстантный указатель на эту же строку  
reinterpret_cast<int *>(777); интерпретирует значение в другой тип данных. Вообще другой!	

104.    C++. Шаблоны классов. Общий синтаксис.


template <class T>  
void swap(T *x, T *y)  //например такая функция  
{
  T z = *x;
  *x = *y;
  *y = x;
}
//здесь описание классов и методов с шаблоном	

105.    C++. Шаблоны функций. Общий синтаксис.

template <typename T>  
//здесь описание классов и методов с шаблоном	

106.    C++. Шаблоны. Что может передаваться через параметры шаблонов?

Классы и имена типов. В один шаблон можно передать несколько параметров, например:  
template<class T, int size = 64>

107.    С++. Можно ли определять шаблоны в CPP-файле? Синтаксис.

Да, но это не является правилом хорошего тона. Тогда например main.cpp будет иметь следующую строку:  
template <class T> void swap(T *x, T *y);  
А в functions.cpp будет описание (см. 104)

108.    С++. placement  new

Работа с памятью через оператор new может быть крайне не желательна в больших системах. Особенно на платформах, где ограниченный размер памяти, например при написание консольных игр. Выделение памяти в куче приводит к ее фрагментации, и через определенное время может не оказаться достаточного свободного блока памяти под новое выделение, что приведет к падению приложения.  
Поэтому придумали placement  new. Вот пример:  

void* ptr = dataBuffer[ offset ]; // указываем позицию в блоке памяти, где мы хотим создать объект.  
SomeClass* cl = new (ptr) SomeClass(); // создаем объект в указанной памяти

Если написать такой код(обычный new):  
SomeClass* cl = new SomeClass(); // то будет выделение памяти в куче, а после создание в ней объекта.


109.    C++. Как грамотно сделать аналог realloc на C++ ?

Move constructor, std::move, reinterpret cast + std::move + placement new  
```cpp
{
int n=2; CString *m =reinterpret_cast<CString*>(new char[n*sizeof(*m)]),*m_;
for(int i=0;i<n;i++)new(m+i) CString();
m_=reinterpret_cast<CString*>(new char[2*n*sizeof(*m)]);
//for(int i=0;i<n;i++)new(m_+i) CString(std::move(m[i]));
for(int i=0;i<n;i++)new(m_+i) CString(const_cast<CString&&>(m[i]));
for(int i=0;i<n;i++)new(m_+i) CString();
delete[] reinterpret_cast<char*>(m);
m=m_;
for(int i=0;i<2*n;i++) m[i].~CString();
delete[] reinterpret_cast<char*>(m);
m=NULL;
}
```

110.    C++. Идея того, как сделать, чтобы оператор [] выполнял бы разные действия слева и справа от знака присваивания.

Нужен класс CTmp: http://lectures.stargeo.ru/tasks-2019/Progs/21/21.bmp

111.    С++. Пример использования auto.

Удобен при использовании шаблонов, например.  
```cpp
template <typename T>  T subtract(T a, T b)
{
    return a - b;
}
 
int main()
{
    auto result = subtract<int>(4, 3); // функция subtract() возвращает значение типа int и, следовательно, переменная result также должна быть типа int
    return 0;
}
```

112.    C++.  initializer_list. Пример использования.

Попроще:  
int * array = new int[7] { 7, 6, 5, 4, 3, 2, 1 };  
Посложнее: (описываем метод некоторого класса ArrayInt):
```cpp
	ArrayInt(const std::initializer_list<int> &list): // позволяем инициализацию ArrayInt через список инициализации
		ArrayInt(list.size()) // используем концепцию делегирования конструкторов для создания начального массива, в который будет выполняться копирование элементов
	{
		// Инициализация нашего начального массива значениями из списка инициализации
		int count = 0;
		for (auto &element : list)
		{
			m_data[count] = element;
			++count;
		}
	}
```

113.    Структуры данных. Чем определяется структуры данных? Общие понятия.

Структура данных — это исполнитель, который организует работу с данными, включая их хранение, добавление и удаление, модификацию, поиск и т.д. Структура данных поддерживает определенный порядок доступа к ним. У структуры есть переменные и функции, которыми она определяется.

114.    Структура данных стек. Определение.

Стек характерен тем, что получить доступ к его элементам можно лишь с одного конца, называемого вершиной стека; иначе говоря: стек – структура данных типа «список», функционирующая по принципу LIFO (last in — first out)

115.    Структура данных стек. Описать класс на С++ для реализации стека (без определения функций).

class stack {  
  float elem[NMAX];  
  int top;  
};  

116.    Структура данных дек. Описать класс на С++ для реализации дека (без определения функций).

class deque {  
  float elem[NMAX];  
  int top,bottom;  
};  

117.    Структура данных очередь. Описать класс на С++ для реализации очереди (без определения функций).

class queue {  
  float elem[NMAX];  
  int first,last;  
};  

118.    Структура данных двунаправленный список. Описать класс на С++ для реализации двунаправленного списка (без определения функций).

struct Node  
{
  uint count;
  string data;
  Node* next;
  Node* prev;
}; 

class List2  
{  
    Node* head;  
    Node* tail;  
    Node* cur;  
};

119.    Структура данных однонаправленный список. Описать класс на С++ для реализации однонаправленного списка (без определения функций).

struct Node  
{
  uint count;
  string data;
  Node* next;
}; 

class List1  
{  
    Node* head;  
    Node* cur;  
};

120.    Структура данных циклический список. Описать класс на С++ для реализации циклического списка (без определения функций).


struct Node  
{
  uint count;
  string data;
  Node* next;
}; 

class List1  
{  
    Node* cur;  
};

121.    Идеи бессылочной реализации списка.  

На основе двух стеков "вершинка к вершинке": http://lectures.stargeo.ru/tasks-2019/Progs/29/29.bmp

122.    Итераторы в стиле STL. Какие функции надо реализовать для реализации такого итератора?

конструктор, булевы операторы сравнения, операторы ++, -- (иногда) и разыменование *.

123.    Итераторы в стиле STL. Написать описание класса для реализации такого итератора (без определения функций).
```cpp
	class iterator{
		Node<T> *cur;
	public:
		iterator(){cur=NULL;}
		iterator(Node<T> *cur){this->cur=cur;}
		bool operator!=(const iterator &rhs){return cur!=rhs.cur;}
		bool operator==(const iterator &rhs){return cur==rhs.cur;}
		void operator++(){if(cur)cur=cur->next;}
		void operator++(int){if(cur)cur=cur->next;}
		T operator*(){return cur->v;}
	};
```

124.    Основные идеи реализации списка с собственным выделением памяти.

При добавлении элемента нужно выделять под него память. При создании пустого списка все указатели обнулить. В деструкторе все удалить :)  
class List2  
{  
    Node* head;  
    Node* tail;  
    Node* cur;  
};

125.    Бинарные деревья. Определение дерева поиска.

Бинарными деревьями называют деревья, в которых, как правило, задан корневой элемент или корень и для каждой вершины существует не более двух потомков  
Бинарное дерево называется деревом поиска, если для любой вершины дерева a ключи всех вершин в правом поддереве больше или равны ключа a, а в левом – меньше. Неравенства можно заменить на строгие, если известно, что в дереве нет равных элементов  
Ветвью дерева называется последовательность вершин дерева, каждый последующий элемент в которой является потомком предыдущего.  
Длиной ветви дерева называется количество элементов в ветви.  
Высотой дерева называется максимальная длина всех ветвей дерева.  

126.    Бинарные деревья. Идеально-сбалансированные деревья. Определение.  

Бинарное дерево называется идеально сбалансированным, если длины всех ветвей, начинающихся в корне дерева и заканчивающихся в узле с хотя бы одним из нулевых указателей v->left и v->right, отличаются не более чем на 1.  

127.    Бинарные деревья. Идеально-сбалансированные’ деревья. Определение.  

 Будем называть идеально сбалансированными’ деревьями такие деревья, для которых для каждой вершины количество элементов в левом и правом поддереве отличается не более, чем на единицу.  

128.    Бинарные деревья. Сбалансированные деревья. Определение.  

Бинарное дерево называется сбалансированным, если для любой его вершины v высоты левого и правого поддерева, выходящих из v (т.е. поддеревьев с корнями v->left и v->right), отличаются не более чем на 1  

129.    Бинарные деревья. Связь между идеально-сбалансированными, идеально-сбалансированными’ и сбалансированными  деревьями.  

Теорема. Идеально сбалансированное’ дерево является идеально сбалансированным.  
Доказательство. Докажем данную теорему по индукции. Для деревьев высоты не более 1 теорема верна. Пусть для деревьев высоты h теорема верна, докажем ее для деревьев высоты h +1.  
По определению идеально сбалансированных’ деревьев, каждое поддерево такого дерева – идеально сбалансировано’, а по условию индукции левое и правое поддеревья корня дерева высоты h+1 – идеально сбалансированы. В идеально сбалансированных деревьях высоты l для количества элементов дерева N выполнено соотношение 2l-1£N<2l, из чего сразу вытекает: если у двух идеально сбалансированных деревьев количество элементов в них отличается не более, чем на единицу, то либо их высоты равны, либо (если количество элементов в них, соответственно, равно 2l-1 и 2l) в меньшем дереве последний слой полностью заполнен. В обоих случаях длины всех ветвей обоих деревьев, начинающихся в корне, заканчивающихся в вершинах, не имеющих хотя бы одного потомка, отличаются не более, чем на единицу. Отсюда сразу вытекает, что и для дерева, полученного с помощью объединения двух таких деревьев с помощью общего корневого элемента, длины всех ветвей, начинающихся в корне, заканчивающихся в вершинах, не имеющих хотя бы одного потомка, отличаются не более, чем на единицу.  

130.    Теорема о связи высоты и количества элементов в сбалансированном дереве. Основная идея доказательства.  

Теорема. Для сбалансированного дерева, состоящего из N вершин, высота дерева h имеет оценку:  
h =Θ(log2N).  
Вывести рекурентную формулу количества элементов от высоты, прологарифмировать и получить нужную оценку  
http://lectures.stargeo.ru/themes/AVL.htm  

131.    Бинарные деревья. Идеально-сбалансированные деревья. Нарисовать пример (в текстовом окошке).  

http://lectures.stargeo.ru/themes/AVL.htm  

132.    Бинарные деревья. Идеально-сбалансированные’ деревья. Нарисовать пример (в текстовом окошке).  

http://lectures.stargeo.ru/themes/AVL.htm  

133.    Бинарные деревья. Сбалансированные деревья. Нарисовать пример (в текстовом окошке).  

http://lectures.stargeo.ru/themes/AVL.htm  

134.    Бинарные деревья. Сбалансированные деревья. Описание на С++ одной вершины сбалансированного дерева.  

class CNode{  
	public:  
		CNode * par, * left, * right;  
		T v; // *T это какой-то другой класс*  
	};  

135.    Бинарные деревья. Деревья поиска. Описание на С++ одной вершины дерева поиска.  
Аналогично 134  

136.    Бинарные деревья. Деревья поиска. Поиск элемента по его индексу. 

(*Тут следует уточнить, что именно спрашивают, тк возможно спрашивают поиск по элементу*) 
Поиск по индексу:  
Найти минимальный элемент, необходимое количество раз найти следующий элемент  
(*Если все-таки по элементу, то*)  
Требуется найти элемент, равный v, в дереве. Введем понятие текущей вершины дерева c. Сначала в качестве c выберем корень дерева. Рекурсивно вызывается следующая процедура:  
Если c==NULL то дерево пусто  
Если v==c то return c  
Если v>=c то выполнить эту же процедуру для c->right  
иначе выполнить эту же процедуру для c->left  

137.    Бинарные деревья. Деревья поиска. Краткое описание алгоритма нахождения минимума/максимума.  

(*минимум*)  
Пусть c - корень дерева  
Пока c->left!=NULL с=с->left  
(*минимум*)  
Пусть c - корень дерева  
Пока c->right!=NULL с=с->right  

138.    Бинарные деревья. Сбалансированные деревья. Краткое описание алгоритма нахождения минимума/максимума.  

Не отличается от деревьев поиска  

139.    Бинарные деревья. Деревья поиска. Краткое описание алгоритма нахождения следующего элемента.  

Если у текущего элемента v есть правый потомок, то следующим элементом будет минимальный элемент в поддереве, которое имеет корень v->right. Иначе мы должны подниматься вверх по дереву, пока не встретиться вершина v, являющаяся левым потомком своего родителя. В этом случае родитель этой вершины будет следующим элементом дерева.  

140.    Бинарные деревья. Сбалансированные деревья. Краткое описание алгоритма нахождения следующего элемента.  

Не отличается от деревьев поиска  

141.    Бинарные деревья. Деревья поиска. Краткое описание алгоритма вставки элемента.  

Требуется добавить в дерево вершину v.  
Для этого ищем лист, после которого следует вставить v и вставляем v после него.  

142.    Бинарные деревья. Сбалансированные деревья. Краткое описание алгоритма балансировки при вставке элемента (понятие вращения /вздергивания элемента можно не уточнять).  

При вставке элемента баланс какого-либо элемента может 2 (случай -2 рассматривается аналогочино, те элемент вставляется в рассматриваемом случае в левое поддерево) 
Пусть в вершине A баланс стал 2  
Рассмотрим его потомков B и C:  
Баланс в точке B стал +1, 0 или -1 (*Возможно иначе до добавления элемента оно не было сбалансированным*)  
Случай при +1 и 0 аналогичен: нужно провести 1 правый поворот  
Случай при -1: нужно провести 1 правый поворот затем 1 левый  

143.    Бинарные деревья. Сбалансированные деревья. Понятие поворота.  

Правый поворот  
Если говорить грубо то, надо взять правый потомок необходимого элемента и "потрясти за него"  
То есть поднять его на уровень выше, а оставшееся поддерево расположить в необходимом порядке  
Аналогично левый поворот  

144.    Бинарные деревья. Сбалансированные деревья. Время работы алгоритма вставки элемента.  

Теорема. В сбалансированное дерево поиска, состоящее из N вершин, можно добавить одну вершину за время O(log2 N). При этом, для балансировки дерева потребуется не более двух поворотов.  
Отметим, что хотя балансировок требуется не более двух, весь процесс балансировки, все же, требует времени O(log2 N), т.к. требуется еще найти – в какой вершине следует производить балансировку.  

145.    Бинарные деревья. Сбалансированные деревья. Сколько поворотов требуется для вставки элемента?

Не более 2 (*см выше*)  

146.    Бинарные деревья. Деревья поиска. Краткое описание алгоритма поиска элемента.  

Пусть дан элемент  
Начинаем с корня  
Если наш элемент больше текущего смотрим правого потомка текущего,  
Если меньше, левый  
Если равен, то мы нашли необходимый элемент

147.    Бинарные деревья. Деревья поиска.  Краткое описание алгоритма удаления элемента.  

Удаление вершины v из дерева поиска не представляет проблем, если данная вершина является листом или имеет всего одного потомка. Иначе, например, из правого поддерева v можно изъять минимальный элемент (самый левый) и поместить его на место удаленного. При этом, дерево останется деревом поиска.  

148.    Бинарные деревья.  Сбалансированные деревья.  Краткое описание алгоритма балансировки при уничтожения элемента (понятие вращения /вздергивания элемента можно не уточнять).  

Само удаление аналогично деревьям поиска  
Отличие заключается в необходимости балансировки после  
Пусть v - это тот элемент, который мы поставили на место удаленного  
Тогда для всех поддеревьев, если понадобится, производим балансировку.  

149.    Бинарные деревья. Деревья поиска. Объединение деревьев со стыковочным элементом.  

Пусть T1<v<T2, то есть каждый элемент T1 меньше V, и каждый элемент T2 больше V  
Тогда объединение деревьев это объявить v корнем нового дерева, причем корень T1 станет в новом левым потомком корня, а T2 - правым  

150.    Бинарные деревья. Деревья поиска. Объединение деревьев без стыковочного элемента.  

Сводится к 149
Пусть T1<T2, то есть каждый элемент T1 меньше каждого элемент T2  
Удалим из T2 минимальный элемент v, T2 станет T2'
Объеденим как T1<v<T2'
Тогда объединение деревьев это объявить v корнем нового дерева, причем корень T1 станет в новом левым потомком корня, а T2 - правым  

151.    Бинарные деревья. Деревья поиска. Разбиение дерева по разбивающему элементу.  

Пусть v некий элемент дерева.  
Он будет называться разбивающим, построим по нему 2 дерева: большее и меньшее чем v  
Рассмотрим v если он правый потомок u, то объеденим левое поддерево v и левое поддерево u по элементу u (*см выше*)  
Если он левый потомок u, то объеденим правое поддерево v и правое поддерево u по элементу u 
Далее рассмотрим вместо v - u
Продолжаем подниматься вверх по дереву пока не дойдем до корня  

152.    Бинарные деревья. Сбалансированные деревья. Объединение деревьев со стыковочным элементом.

Объединение со стыковочным элементом и без почти не отличаются (*См 150*)
Пусть высота T1 больше или равна T2  
Рассмотрим правую ветвь T1. Так как разница высот между элементами этой ветви меньше или равна 2,  
то найдется в этой ветви элемент v1, высота которого равна высоте T2 или больше ее на 1  
Объеденим дерево начинающееся с v1 и T2 по элементу v (*Который дается в условиях*)  
И поставим на место v1 новое дерево  
Высота дерева, начинающегося с v1 увеличится на 1  
Итак, в результате изменений дерева у одной вершины w длина соответствующего поддерева увеличилась на 1.  
Далее нам следует запустить стандартную процедуру балансировки дерева. Мы должны пройти ветвь, заканчивающуюся на w, от w до корня и в каждой вершине проверить баланс.  
Если он будет по модулю больше 1, то баланс в данной вершине следует скорректировать одним или двумя вращениями.  
Если, при этом, длина данного поддерева восстановится до значения, которому она была равна до слияния деревьев, то далее процесс проверки сбалансированности производить не надо (т.к. дерево T1 до слияния было сбалансированным). Иначе, процесс проверки следует продолжить  

153.    Бинарные деревья. Сбалансированные деревья. Время работы алгоритма объединения деревьев со стыковочным элементом.

Теорема. Для двух сбалансированных деревьев поиска T1 и T2, состоящих из N1 и N2 вершин, имеющих высоты h1 и h2, и элемента v, таких, что все элементы в T1 меньше или равны v и v меньше или равно всех элементов в T2:  
слияние деревьев с помощью стыковочного элемента v в одно сбалансированное дерево поиска T можно произвести за время T=O(log2 (N1+N2) ) или за время T=O(|h1-h2|). Указанные деревья T1 и T2 можно слить за время T=O(log2 (N1+N2) ).

154.    Бинарные деревья. Сбалансированные деревья. Время работы алгоритма объединения деревьев без стыковочного элемента.

Аналогично 153
Но отметим здесь, что для слияния двух сбалансированных деревьев требуется сначала извлечения стыковочный элемент из дерева с большей высотой, поэтому эта операция требует большего времени, чем слияние деревьев с готовым стыковочным элементом.  
(*Теорема. Из сбалансированного дерево поиска, состоящего из N вершин, можно удалить одну вершину за время O(log2 N).*)  

155.    Бинарные деревья. Сбалансированные деревья. Разбиение дерева по разбивающему элементу.  

Алгоритм, практически полностью, совпадает с алгоритмом разбиения обычного дерева поиска. Только, теперь, нам следует пользоваться алгоритмом слияния деревьев для сбалансированных деревьев поиска.  

156.    Бинарные деревья. Сбалансированные деревья. Время работы алгоритма разбиения дерева по разбивающему элементу.  

Теорема. Для данной вершины v сбалансированного дерева поиска T разбиение на два сбалансированных дерева поиска T1 и T2 таких, что все элементы в T1  меньше или равны v, и все элементы в T2  больше или равны v. может быть произведено указанным алгоритмом за время  = O(log2 N), где N – суммарное количество вершин в деревьях T1 и T2.

157.    Подход к решению задачи создания структуры данных для хранения множества непересекающихся отрезков на числовой прямой.

Хранить отрезки в AVL (сбалансированном) дереве. У отрезков есть порядок, тк они не пересекаются  
Добавление отрезка (возмножно пересекающегося с данными) будет происходить как объединение дерева из отрезков строго левее объединяющегося и строго правее по элементу равному объединению необходимых отрезков

158.    Красно-черные деревья. Определение.

Красно-черными деревьями  называют бинарные деревья поиска, у которых для каждой вершины добавляется дополнительное свойство: вершина является черной или красной. При этом требуется выполнение следующих свойств:  
·  корень дерева – черный  
·  у каждой красной вершины потомки – черные  
·  в любых двух ветвях от корня до листа количество содержащихся черных вершин равно (здесь листом называется вершина, у которой есть не более одного потомка)

159.    Красно-черные’ деревья. Определение.

Введено для того, чтоб все поддеревья К-Ч дерева моно было назвать К-Ч'.
·  у каждой красной вершины потомки – черные  
·  в любых двух ветвях от корня до листа количество содержащихся черных вершин равно 

160.    Красно-черные деревья. Описание класса на языке С++ для хранения одной вершины красно-черного дерева.

typedef struct SBTree_  
{
 int IsRed;
 int value;  
 struct STree_ *par;  
 struct STree_ *left, *right;  
} SBTree;

161.    Красно-черные деревья. Теорема о связи количества элементов и высоте.

 В красно-черном дереве с черной высотой hb количество внутренних вершин не менее 2^(hb+1)-1.

162.    В-деревья. Определение.

В-дерево степени n определяется следующим образом  
·      каждая вершина дерева, кроме корня, содержит от n-1 до 2n-1 элемента (ключей) и от n до 2n ссылок на дочерние элементы; корень дерева содержит не более 2n-1 элементов (ключей) и не более 2n ссылок на дочерние элементы  
·      В-дерево идеально сбалансировано, более того, длины всех ветвей от корня до листа совпадают;  
·      элементы в каждой вершине упорядочены по возрастанию  
·      если в вершине содержится k элементов, то в ней содержится k+1 ссылок на дочерние вершины (кроме листьев, ссылок на дочерние вершины не содержащих);  
·      элементы в вершине и ссылки на дочерние вершины сопоставляются следующим образом: про первую ссылку говорят, что она располагается до первого элемента, про последнюю – что она располагается после последнего элемента, остальные ссылки располагаются каждая – между некоторой парой элементов в вершине;  
·      все элементы xi в поддереве V, ссылка на которое расположена после некоторого элемента y, больше y; все элементы xj в поддереве V, ссылка на которое расположена до некоторого элемента z меньше z.


163.    В-деревья. Теорема о связи количества элементов и высоте.

Теорема. Для В-дерева степени n, содержащего N элементов, высоты h верна оценка для высоты  
h=Q(lognN).  
Верна точная оценка  
h <= logn((N+1)/2)+1.

164.    В-деревья. Алгоритм поиска элемента.

Поиск вершины, содержащей заданный элемент (или элемент с ключом, равным заданному), осуществляется аналогично поиску в двоичном дереве поиска. Единственное отличие – для каждой вершины процедура поиска данного элемента более сложная, чем для случая дерева поиска. На языке С поиск элемента, равного v, в В-дереве с корнем root можно оформить в виде следующей функции

BNode *BSearch(BNode *root, int v)  
{  
  if(root==NULL)return NULL;  
  for(i=0;i<root->n;i++)  
   if(root->value[i]==v)return root;  
   else if(root->value[i]>v)return BSearch(root->child[i],v);  
 return BSearch(root->child[i],v);  
}

165.    В-деревья. Добавление элемента. Основные идеи.

1)    По аналогии с деревом поиска сначала ищется лист, в который можно вставить новый элемент (это – первый проход по дереву).  
2)    Заметим, что листом дерева называется элемент без потомков. Если найденный лист V не заполнен, то новый элемент вставляется в лист V В-дерева степени n и на этом процедура завершается.  
3)    Иначе в элементах данной вершины находится медиана x и вершина разбивается на две вершины по n-1 элементу в каждой, причем элементы в первой вершине V-  должны быть меньше x, а во второй V+  – больше x.  
4)    Элемент x вставляется в массив элементов в родительской вершине между элементами, между которыми находилась ссылка на вершину V. Ссылки на вершины V-  и V+ должны расположиться непосредственно слева и справа от x.  
5)    Теперь новый элемент можно вставить в одну из вершин V-  или V+.  
6)    После этого, если в родительской вершине количество элементов становится меньше 2n-1, то на этом процедура завершается. Иначе процедура разбиения вершины рекурсивно применяется для родителя (т.е. переходим к шагам 3, 4, 6). В этом заключается второй проход по дереву.  
В худшем случае процедура будет последний раз применена для корня дерева и дерево увеличит свою высоту на 1. 

166.    В-деревья. Удаление элемента. Основные идеи.

Для удаления элемента, равного заданному, требуется, сначала, его найти. При осуществлении поиска мы параллельно будем обеспечивать условие, гарантирующее, чтобы в вершине, из которой будет удаляться элемент, было бы не менее n элементов (по определению В-дерева достаточно, чтобы в вершине присутствовало не менее n-1 элемента).  

Итак, в процессе поиска вершины, содержащей удаляемый элемент v, мы вводим понятие текущей вершины x. Текущая вершина перемещается от корня дерева по соответствующей ветви к вершине, содержащей удаляемый элемент.

Для каждого очередного значения текущей вершины возможен один из следующих вариантов.  
1) Вершина является листом.  

Если, при этом, вершина - корень (все дерево состоит из одной вершины), то мы просто удаляем найденный элемент из этой вершины (если элемент найден). Если дерево состоит более, чем из одной вершины, то в результате выполнения следующих пунктов, данная вершина содержит не менее n элементов и найденный элемент можно исключить из данной вершины (если он нашелся, иначе - элемент отсутствует в дереве).  

2) Вершина x - внутренняя. Элемент v в вершине x не найден.  
Ищем потомка x->child[i] вершины x, с которого начинается поддерево,
содержащее элемент v (если он вообще есть в дереве). По условию мы должны гарантировать, чтобы в вершине x->child[i] содержалось бы не менее n элементов. Если это выполняется, то переходим к рассмотрению этой вершины:

x=x->child[i].  
Иначе мы либо перетаскиваем один элемент из брата вершины x->child[i] в
вершину x->child[i], либо, если это невозможно, объединяем данную вершину с братом. Более подробно, есть два варианта:

   а) У вершины x->child[i] есть брат, содержащий не менее n элементов.

У данной вершины есть сосед (левый), содержащий 3 элемента. Тогда мы максимальный элемент из этой вершины – 7 – помещаем на место 10, а 10 помещаем на мес
   б) У вершины x->child[i] все братья содержат n-1 элемент.
   
3) Вершина x - внутренняя, в вершине найден элемент x->value[i]==v.  
Сначала удаление производится аналогично дереву поиска: в одном из поддеревьев, соседних данной вершине, например, для определенности, в правом соседнем поддереве данной вершины (т.е. в поддереве, начинающемся с вершины                       x->child[i+1]) находим элемент v0, ближайший к v. В нашем случае это – минимальный элемент поддерева, начинающегося с вершины x->child[i+1]. Заметим, что минимальный элемент в поддереве B-дерева является первым элементом некоторого листа.

Далее, помещаем элемент v0 на  место элемента v и запускаем процедуру удаления старого (т.е. удаленного) элемента v0.

167.    В+-деревья. Определение.

B+-дерево степени n определяется следующим образом.  
·      каждая вершина дерева, кроме корня, содержит от n-1 до 2n-1 элемента (ключей) и от n до 2n ссылок на дочерние элементы; корень дерева содержит не более 2n-1 элементов (ключей) и не более 2n ссылок на дочерние элементы  
·      В+-дерево идеально сбалансировано, более того, длины всех ветвей совпадают;  
·      элементы в каждой вершине упорядочены по возрастанию  
·      если в вершине содержится k элементов, то в ней содержится k+1 ссылок на дочерние вершины (кроме листьев, ссылок на дочерние вершины не содержащих);   
·      элементы в вершине и ссылки на дочерние вершины сопоставляются следующим образом: про первую ссылку говорят, что она располагается до первого элемента, про последнюю – что она располагается после последнего элемента, остальные ссылки располагаются каждая – между некоторой парой элементов в вершине;  
·      все элементы xi в поддереве V, ссылка на которое расположена после некоторого элемента y, БОЛЬШЕ ИЛИ РАВНЫ y; все элементы xj в поддереве V, ссылка на которое расположена до некоторого элемента z меньше z.  
·      ССЫЛКИ НА ДАННЫЕ ЛЕЖАТ ТОЛЬКО НА НИЖНЕМ УРОВНЕ ДЕРЕВА (В ЛИСТЬЯХ); ВО ВСЕХ ОСТАЛЬНЫХ ВЕРШИНАХ ЛЕЖАТ ТОЛЬКО КОПИИ КЛЮЧЕЙ ЭЛЕМЕНТОВ С НИЖНЕГО УРОВНЯ, ИСПОЛЬЗУЮЩИЕСЯ ДЛЯ ИНДЕКСИРОВАНИЯ.

168.    STL. Последовательные контейнеры.  

vector, deque(stack,queue,priority_queue), list  

169.    STL. Ассоциативные контейнеры.

map(multimap),set(multiset) (*Основаны на деревьях*)

170.    STL. vector. Основные функции.  

(*Основан на массиве*)  
resize(n) -- изменение размера вектора до n  
Обращение через [i]  
at(i) -- что и [i], но с гарантированной проверкой за выход за границу массива  
size() -- возвращает длину вектора  
capactity () -- возвращает количество элементов, под которые выделена память  
empty() -- пуст ли вектор  
clear() -- очистить вектор (с очисткой памяти)  
push_back(x) -- добавление в конец с выделением памяти  
emplace_back(x) -- добавление с использованием placement new  
insert(it,x) -- вставить по итератору it x  
emplace(it,x) -- добавление по итератору it с использованием placement new  
insert(it,it1,it2) -- добавление с позиции it часть вектора (*чаще всего другого*) начиная с it1 до it2  
Так же с emplace нельзя  

171.    STL. deque. Основные функции. 

swap, std::swap 	
shrink_to_fit, clear, insert, emplace, push_front, push_back, emplace_front, emplace_back 	
erase 	
resize 	 
pop_front  
pop_back

172.    STL. queue. Основные функции. 

front  
back  
empty  
size  
push  
emplace  
pop  
swap  

173.    STL. Когда лучше применять дек, а когда вектор (в соответствии с внутренним строением)?

Преимущества deque перед vector:  
1. Меньше overhead. Вектор растет сразу в два раза, а дек - фиксированными страницами.  
2. Отстуствие копирования старого содержимого на новое место при расширении контейнера.  
Недостатки:  
1. Отсутствие доступа к содержимому как к линейному массиву.  
Инкремент-декремент итераторов у деки по скорости сравнимы с векторными, произвольный доступ к элементам - аналогично.  

174.    STL. list. Основные функции. 

front	
back	
begin cbegin	
end cend	
rbegin crbegin	
rend crend	
empty	
size	
max_size	
clear	
insert	
emplace		
erase	
push_back,emplace_back,pop_back 	 
push_front,emplace_front,pop_front 	 
resize 	 
swap 	 

175.    STL. map. Основные функции. 

map<key, set<value>> будет хранить каждое значение только один раз для определенного ключа.
empty	
size	
max_size	
clear	
insert	
insert_or_assign(C++17)	 
emplace	 
emplace_hint	
try_emplace(C++17)	
erase	
swap	
extract(C++17)	
merge(C++17)	
count	
find	
contains(C++20)	  
equal_range	
lower_bound   
upper_bound  
key_comp  
value_comp  

176.    STL. set. Основные функции. 

=map , но std::set содержит только ключ, а в std::map есть связанное значение, то есть,  
если A -> B, тогда отображение [A] => B, это работает как hashing, но не O(1), а не O(log N).

177.    STL. multimap. Основные функции.

=map , но multimap хранит пары (ключ, значение), где ключ и значение могут появляться несколько раз.  

178.    STL. multiset. Основные функции. 

=set , но multiset также будет хранить повторяющееся элементы, по сравнению с множеством set. 

179.    STL. queue. Основные функции. 

front  
back  
empty  
size  
push  
emplace  
pop  
swap  

180.    STL. priority_queue. Основные функции. 

top
empty  
size  
push  
emplace  
pop  
swap  
~=queue, отсортированная пользовательским сравнением Compare.

181.    STL. Функциональные объекты. Общее описание реализации.

 Функтор — это сокращение от функциональный объект, представляющий собой конструкцию, позволяющую использовать объект класса как функцию. В C++ для определения функтора достаточно описать класс, в котором переопределена операция ().

182.    STL. Функциональные объекты. Пример собственного определения.

struct Comp  
{  
    bool operator()(const std::string &s1, const std::string &s2) const  
    { return s1.length() < s2.length(); }  
};

183.    STL. Алгоритмы. Несколько примеров.

min_element() и max_element()  
find() и list::insert()  
sort() и reverse()  
пример1:  
list<int> li;  
    for (int nCount=0; nCount < 5; ++nCount)  
        li.push_back(nCount);  
list<int>::const_iterator it; // объявляем итератор  
    it = min_element(li.begin(), li.end());  
        std::cout << *it << ' ';  
пример2:  
std::vector<int> vect;
    vect.push_back(4);
    vect.push_back(8);
    vect.push_back(-3);
    vect.push_back(3);
    vect.push_back(-8);
    vect.push_back(12);
    vect.push_back(5);
 sort(vect.begin(), vect.end()); // выполняем сортировку элементов вектора  
 vector<int>::const_iterator it; // объявляем итератор  
    for (it = vect.begin(); it != vect.end(); ++it) // выводим с помощью цикла и итератора элементы вектора  
        std::cout << *it << ' ';  

184.    Хеширование. Набор предписаний для структуры данных, основанной на хешировании. 

- Создать  
- Уничтожить  
- Очистить  
- Пусто ли?  
- Добавить элемент  
- Найти элемент (Есть ли элемент в множестве?)  
- Уничтожить элемент  

185.    Хеширование. Простой пример хеширование для работы со строками. 

При работе со строками можно взять первые 2 байта и представить их как беззнаковое целое число это число от 0 до ~65 тысяч
(*Далее само определение хеш-функции*)
Пусть есть множество X  
Хеш-функция h(x): X-> {0,...,M-1}  
Вероятность для заданного i h(x)=i одинакова для всех i и равна p=1/M  

186.    Хеширование. Метод многих списков. Общее описание.  

Массив из M списков  
При добавлении элемента x в множество вычисляеется h(x)  
Элемент добавляется в список с индексом h(x)  

187.    Хеширование. Метод многих списков. Оценка сверху на время добавление элемента.  
Θ(N) (см 188)  

188.    Хеширование. Метод многих списков. Оценка среднего времени на добавление элемента.  

Теорема. Если хэш-функция h(x) с равной вероятностью принимает все свои значения 0<=h(x)<M,    
то среднее время поиска, добавления, удаления элемента в хэшируемом множестве, реализованном с помощью метода многих списков,  
T(N,M) = Θ(N/M).  
В худшем случае для поиска, добавления, удаления элемента требуется время, равное Θ(N).  

189.    Хеширование. Метод многих списков. Основные идеи удаления элемента.

(*Как-то просто, даже сомнительно*)  
При удалении элемента x из множества вычисляеется h(x)=i  
После в i-ом списке происходит удаление элемента равного x

190.    Хеширование. Метод многих списков. Основные идеи добавления элемента.

При добавлении элемента x в множество вычисляеется h(x)=i  
После в i-ый список добавляется элемент x  

191.    Хеширование. Метод многих списков. Стратегия работы с подобной структурой данных для обеспечения времени выполнения основных операций = O(1). 

Для обеспечения быстрой в среднем работы количество списков M должно быть равно Θ(N)  
Тогда при достижении например количества элеметов в 4 раза большего списков необходимо изменять количество списков например в 2 раза  
При этом если наша хеш-функция зависит от количества списков, необходимо пересчитать значения каждого элемента  
Иначе говоря нужно построить заново хеш-множество  

(*Общее описание метода линейных проб*)  
Можно попробовать использовать для хранения данных таблицу без ссылок. Будем дополнительно в каждой ячейке таблицы хранить информацию о том – занята ли ячейка или нет.  
Если при занесении в таблицу нового элемента хэш-функция от заносимого значения укажет на пустую ячейку, то проблем никаких нет. Иначе, получается ситуация,  
называемая коллизией. Разрешение коллизий является основной целью при создании алгоритмов работы с хешируемыми множествами.  

Способ разрешения коллизий в таблице следующий: если элемент, на который указывает хэш-функция, занят, то мы рассматриваем   
последовательно все элементы таблицы от текущего, пока не найдем свободной место. Новый элемент помещается в найденное свободное место.  

192.    Хеширование. Метод линейных проб. Добавление элемента.  

При добавлении вычисляется значение хеш-функции, после проверяется пуста ли ячейка, на которую указывает  
хеш-функция, если пуста, то элемент добавляется по данному значению хеш-функции (*думаю, можно сказать по адресу*)  
если не пуста, то проверяем следующую ячейку до тех пор, пока она не станет пустой.  
В эту пустую ячейку кладется наш элемент  

193.    Хеширование. Метод линейных проб. Удаление элемента.

Удаление элемента из таблицы несколько более сложное, чем добавление и поиск. Нельзя просто объявить позицию i, в которой требуется удалить элемент, пустой.  
Если это сделать, то элемент value[j] с индексом j<i, для которого h(value[j])≥i и для которого все элементы с индексами между j и i заняты, окажется потерянными  
для последующего поиска (здесь мы рассматриваем случай отсутствия "перескока" в конец массива при поиске очередного элемента). Действительно, при поиске этого элемента  
мы обязательно натолкнемся на пустую позицию value[i] и поиск будет завершен.
Чтобы исправить ситуацию мы должны найти первый такой элемент value[j], перенести его значение в позицию i и свести задачу к удалению элемента value[j].  
Естественно, мы должны учитывать возможность "перескока" в конец массива при поиске такого value[j].  

194.    Основные идеи реализации хэш-функции на основе деления.  

Пусть требуется для числа A получить значение хэш-функции. Предлагается в качестве хэш-функции использовать остаток от деления A на некоторое K  
h(A)=A (mod K)  
(*Из книги далее*)
Зачастую хорошие результаты можно получить, выбирая в качестве значения K простое число, достаточно далекое от степени двойки

195.    Основные идеи реализации хэш-функции на основе умножения.  

Алгоритм вычисления хэш-функции, основывающийся на умножении, задается следующей формулой  
h(A) = [M({AK/R})]
здесь фигурные скобки являются оператором взятия дробной части, квадратные скобки являются оператором взятия целой части,  
R – размер машинного слова, в котором размещается A (например, если A размещается в целой 32-битной переменной, то R=232),  
K – некоторое число, взаимно простое с R. В качестве M часто выгодно брать M=2m.
Алгоритм является обобщением алгоритма, основанного на делении. Действительно, пусть K есть некоторое приближение к R/S, M=S, то
h(A) = [M({AK/ R})] = [S({A / S})] ~ A%S
Практически, алгоритм сводится к следующему: ставится десятичная точка перед числом A, полученное число умножается на K, из результата берутся первые m бит,  
расположенных после десятичной точки (здесь под десятичной точкой имеется в виду разделитель целой и дробной части в позиционной системе отсчета).

196.    CRC-алгоритм проверки целостности данных на основе представления числа как многочлена с коэффициентами в поле вычетов по модулю 2. Основные идеи.  

Представим наш файл в виде последовательности бит  
abcde... где каждая буква это число 0 или 1, что равно числу в кольце вычетов по модулю 2  
Представим эту последовательность как коэффициенты многочлена  
a(x^n-1)+b(x^n-2)...  
Возьмем любой другой удобный (*в смысле удобный для реализации*) многочлен  
A(x^k-1)+B(x^k-2)...  
Поделим первый многочлен на второй (столбиком, в этом кольце есть сложение, вычитание, умножение и деление)  
A_(x^k-2)+B_(x^k-3)...  
Тогда, если дописать исходным коэффициентам получившиеся, то новый многочлен будет делиться нацело  
В итоге легко можно отследить возмножное изменение данных в файле по отличию от нуля  
вычисленных вновь коэффициентов  

197.    Графы. Определение. Ориентированные и неориентированные графы.

Графом называется пара G=(V,E), где V - множество объектов произвольной природы, называемых вершинами (vertices, nodes), а E - семейство пар ei=(vi1, vi2), vij из V, называемых ребрами (edges).  
Если порядок элементов, входящих в ei, имеет значение, то граф называется ориентированным (directed graph), сокращенно - орграф (digraph), иначе - неориентированным (undirected graph). Ребра орграфа называются дугами (arcs).

198.    Графы.  Инцидентность/смежность вершин/ребер. 

Некоторая вершина и некоторое ребро графа называются инцидентными, если вершина является одной из вершин ребра. Соответственно, пара вершин инцидентна ребру, если эти вершины являются вершинами одного ребра, а сами вершины называются смежными. Два ребра графа называются смежными, если они инцидентны одной вершине.

199.    Графы. Теорема о графическом представлении графов в R3.

Теорема 2.  Для любого конечного графа существует его геометрическое представление в R3.  
Доказательство. Рассмотрим произвольный отрезок [a,b]Ì R3. Сопоставим всем вершинам графа различные точки на отрезке [a,b]. Сопоставим каждому ребру графа свою плоскость, проходящую через [a,b]. Плоскости, соответствующие ребрам, пересекаются только вдоль отрезка [a,b], поэтому в каждой плоскости можно нарисовать кривую, соединяющую вершины, инцидентные соответствующему ребру, которая не пересекается с другими построенными кривыми нигде, кроме как в вершинах графа.

200.    Графы. Планарные графы.

Граф называется планарным, если существует его геометрическое представление в R2.

201.    Графы. Теорема о существовании плоской укладки графов.

 Плоской укладкой планарного графа называется такое его геометрическое представление, при котором каждое ребро представляется отрезком на плоскости.
 Теорема. Для любого конечного планарного графа без кратных ребер и петель существует его плоская укладка.  
Иногда в литературе последнее утверждение выступает в виде определения планарного графа, а не его свойства.

202.    Приведение неориентированного дерева к ориентированному.

Ориентированным деревом называется ориентированный граф, являющийся деревом, для которого ровно одна вершина имеет нулевую степень захода (степень захода = количество ребер заходящих в вершину), а все остальные вершины имеют степень захода, равную 1. Для случая ориентированного графа конечной вершиной называется вершина, имеющая нулевую степень исхода (степень исхода  = количество ребер выходящих из вершины). Это определение отличается от определения для неориентированного дерева!  
Лемма 1. Любое конечное неориентированное дерево имеет плоскую укладку.   
Лемма 2. В любом конечном дереве можно ввести ориентацию, т.е. для ребер произвольного дерева можно задать ориентацию так, что дерево станет ориентированным.

203.    Теорема о существовании плоской укладки дерева.

(*плохо сформулировано*)
(*Легче воспринимать, что дерево должно "лечь" на прямую*)  
Дерево имеет плоскую укладку. По построению выбираем корень на плоскости  
Далее проводим линию не проходящую через точку "корня"  
Строим на этой прямой точки элементов графа связанных с корнем  
Для того чтобы построить следующие точки выберем их на прямой параллельной данной  
и ограниченной продлженниями прямых, проведенных через текущую точку и "корень"

204.    Графы. Основное утверждение, на котором строится алгоритм волны.  

В новом уровне волны нет точек из предыдущих волн.  

205.    Графы. Время работы алгоритмы волны для случая графа без кратных ребер и петель.  

O(P)  

206.    Графы. Формула Эйлера.  

кол-во вершин - кол-во ребер + кол-во граней = 2  
p-q+r=2  

207.    Оценка количества ребер и граней конечного планарного графа через количество вершин. Основные идеи доказательства.

q<=3p
Рассмотрим планарный граф без кратных ребер и петель, в каждой связной компоненте которого есть хотя бы три ребра. В его плоской укладке для каждой грани i количество ребер на ее границе qi>=3. Т.о. имеем  
C другой стороны каждое ребро принадлежит не более, чем двум граням, поэтому  
Тогда по формуле Эйлера, примененной для i-ой связной компоненты графа, имеем:  q<=3p  

208.    Теорема о времени работы алгоритма волны для случая планарного графа.

Для случая планарного графа без кратных ребер и петель, состоящего из N вершин, алгоритм волны работает за время O(N).  

209.    Основное утверждение, на котором строится алгоритм Дейкстры.  

Пусть S[k] множество, состоящее из k элементов.  
Элементом данного множества является вершина x, минимальное расстояние от a до x  
Утверждается, что ближайшая вершина графа к a  
из вершин, не внесенных в S[k], есть точка на которой достигается минимум  
суммы длины между точкой от a до какой-то точки, лежащей внутри S[k] и точкой, лежащей вне S[k].  

210.    Простой алгоритм Дейкстры.  

Алгортим реализует поиск кратчайшего пути от вершины a до b  
Пусть S[k] множество, состоящее из k элементов.  
Элементом данного множества является вершина x, минимальное расстояние от a до x  
Также будем хранить указатель на предыдущую вершину (*для того, чтобы построить путь обратно*)  
Сам алгоритм состоит в том, что будем создавать новые S[k]  
(*то есть последовательно искать все точки по нарастанию длины от данной*)

Будем в каждой вершине из S[k] хранить длину кратчайшего пути до этой вершины из a или  
минимум расстояния от a до смежной с этой равный I и ссылку на вершину, из которой мы пришли по кратчайшему пути  
S[0]=a  
Тогда для всех вершин вне S[k] ищем минимум I   
y это элемент, на котором достигается минимум, причем y лежал вне S[k]  
Если такого y нет, то a и b лежат в разных компонентах свзяности, то есть между ними нет пути  
Запомним в y вершину из которой пришли  
Тогда S[k+1]=y+S[k]   
Вычичляем новое I  
Повторяем процедуру пока y!=b

211.    Модифицированный алгоритм Дейкстры.

(*Не считаю этот ответ достаточно полным*)
Проанализировав алгоритм для случая планарных графов без кратных ребер и петель, мы сможем заметить, что его можно улучшить. Действительно, при коррекции I для каждой вершины перебираются все смежные ребра и это происходит ровно один раз. Поэтому суммарное количество операций по коррекции I не превосходит O(q), где q – количество ребер, а для рассматриваемого случая O(q)= O(p), где p – количество вершин графа.
Допустим, что мы сможем создать структуру данных, содержащую вещественные числа, в которую можно добавлять элементы, удалять из нее минимальный элемент, искать минимум элементов, модифицировать положение элемента при изменении его значения, причем каждая из этих операций должна выполняться за время O(log N), где – N количество элементов, занесенных в данную структуру. Назовем множество, реализованное с помощью указанной структуры данных, P. Назовем множество, реализованное с помощью указанной структуры данных, P.  
На каждом шаге вышеописанного алгоритма мы можем хранить в множестве P  ссылки на все элементы, содержащие вершины, смежные с вершинами очередного  S[k], которые сами в S[k] не содержатся. Заметим, что именно среди этих элементов происходит коррекция I и поиск минимально I. На каждом шаге алгоритма Дейкстры мы должны сначала добавить в P  ссылки на все элементы, смежные y, при изменении значений I  модифицировать положение соответствующих элементов, а в конце извлечь из P  ссылку на элемент с минимальным значением I.

212.    Алгоритм Дейкстры для STL.

Скопирован с сайта, но в лекциях не сильно отличался.
```cpp
#include <stdio.h>
#include <iostream>
#include <fstream>
#include <vector>
using namespace std;
struct SPoint{SPoint(){l=1.e101;iback=-1;s=0;} double x,y,l;int iback,s;};
struct SEdge{int i0,i1; double d; int operator()(int i){return i==i0?i1:i0;}};
ifstream &operator>>(ifstream &f,SPoint &p){f>>p.x>>p.y; return f;}
ifstream &operator>>(ifstream &f,SEdge &p){f>>p.i0>>p.i1>>p.d; return f;}
 
int main(void)
{vector<SPoint> p; vector<SEdge> e; vector<vector<int>> n;
 int i0=0,i1=11,j;double l; int ipt;
 //--
 {SPoint P; ifstream f("vertex.txt"); while(f>>P)p.push_back(P);}//ввод вектора вершин из файла c к-тами вершин в формате x y
 {SEdge E;  ifstream f("edges.txt"); while(f>>E)e.push_back(E);} //ввод вектора ребер из файла с номерами вершин ребра и его длиной в формате i0 i1 d
 n.resize(p.size());
 for(size_t i=0;i<e.size();i++)
 {n[e[i].i0].push_back(i);n[e[i].i1].push_back(i);}
 //--
 for(ipt=i0,p[i0].l=0,p[i0].s=1;ipt!=i1;)
 {
  for(vector<int>::iterator i=n[ipt].begin();i!=n[ipt].end();i++)
   if((l=p[ipt].l+e[*i].d)<p[j=e[*i](ipt)].l)//мы сознательно не проверяем, что p[j].s==0
   {p[j].iback=ipt;p[j].l=l;}
  l=1.e100;ipt=-1;
  for(size_t i=0; i<p.size(); i++)if(p[i].s==0&&p[i].l<l)
  {ipt=i;l=p[i].l;}
  if(ipt<0)goto le;
  p[ipt].s=1;
 }
//--
 cout<<"l="<<p[i1].l<<endl;
 for(int k=i1;k>=0;k=p[k].iback)cout<<k<<" "; cout<<endl;
 return 0;
le:
 cout<<"can't find way"<<endl;
 return 0;
}
```

213.    Модифицированная приоритетная очередь. Основные операции.

Модификацмя заключается в функциях Heapify, correct и возможности удаления не только первого элемента.  
http://lectures.stargeo.ru/tasks-2019/Progs/45/45.bmp

214.    Модифицированная приоритетная очередь. Алгоритм добавления элемента.  

void push(T &x) {v.push_back(x); correct(v.size()-1);}  
void correct(size_t i) {T tt; for(;i>0;i=(i-1)/2) if(v[(i-1)/2]<v[i]) {SWAP(v[i],v[(i-1)/2]);} else break;}  
http://lectures.stargeo.ru/tasks-2019/Progs/45/45.bmp

215.    Модифицированная приоритетная очередь. Алгоритм модификации элемента.

Стоит сделать оговорку, что используется второй шаблон Tv для реализации разного поведения оператора скобки[] до и после знака =.  
void dec(size_t i, Tv x){v[i]=x; correct(i);}  
void correct(size_t i) {T tt; for(;i>0;i=(i-1)/2) if(v[(i-1)/2]<v[i]) {SWAP(v[i],v[(i-1)/2]);} else break;}  
http://lectures.stargeo.ru/tasks-2019/Progs/45/45.bmp

216.    Модифицированная приоритетная очередь. Алгоритм удаления первого элемента.

void pop() {erase(0);}  
void erase(size_t i) {T tt; SWAP(v[i], v[v.size()-1]); v.resize(v.size()-1); Heapify(i,v,size());}  
http://lectures.stargeo.ru/tasks-2019/Progs/45/45.bmp

217.    C/C++. Модель памяти. Стек/куча.

Стек — это область оперативной памяти, которая создаётся для каждого потока. Он работает в порядке LIFO (Last In, First Out),  то есть последний добавленный в стек кусок памяти будет первым в очереди на вывод из стека. Каждый раз, когда функция объявляет новую переменную, она добавляется в стек, а когда эта переменная пропадает из области видимости (например, когда функция заканчивается), она автоматически удаляется из стека. Когда стековая переменная освобождается, эта область памяти становится доступной для других стековых переменных.

Из-за такой природы стека управление памятью оказывается весьма логичным и простым для выполнения на ЦП; это приводит к высокой скорости, в особенности потому, что время цикла обновления байта стека очень мало, т.е. этот байт скорее всего привязан к кэшу процессора. Тем не менее, у такой строгой формы управления есть и недостатки. Размер стека — это фиксированная величина, и превышение лимита выделенной на стеке памяти приведёт к переполнению стека. Размер задаётся при создании потока, и у каждой переменной есть максимальный размер, зависящий от типа данных. Это позволяет ограничивать размер некоторых переменных (например, целочисленных), и вынуждает заранее объявлять размер более сложных типов данных (например, массивов), поскольку стек не позволит им изменить его. Кроме того, переменные, расположенные на стеке, всегда являются локальными.

Куча

Куча — это хранилище памяти, также расположенное в ОЗУ, которое допускает динамическое выделение памяти и не работает по принципу стека: это просто склад для ваших переменных. Когда вы выделяете в куче участок памяти для хранения переменной, к ней можно обратиться не только в потоке, но и во всем приложении. Именно так определяются глобальные переменные. По завершении приложения все выделенные участки памяти освобождаются. Размер кучи задаётся при запуске приложения, но, в отличие от стека, он ограничен лишь физически, и это позволяет создавать динамические переменные.

Вы взаимодействуете с кучей посредством ссылок, обычно называемых указателями — это переменные, чьи значения являются адресами других переменных. Создавая указатель, вы указываете на местоположение памяти в куче, что задаёт начальное значение переменной и говорит программе, где получить доступ к этому значению. Из-за динамической природы кучи ЦП не принимает участия в контроле над ней; в языках без сборщика мусора (C, C++) разработчику нужно вручную освобождать участки памяти, которые больше не нужны. Если этого не делать, могут возникнуть утечки и фрагментация памяти, что существенно замедлит работу кучи.

В сравнении со стеком, куча работает медленнее, поскольку переменные разбросаны по памяти, а не сидят на верхушке стека. Некорректное управление памятью в куче приводит к замедлению её работы; тем не менее, это не уменьшает её важности — если вам нужно работать с динамическими или глобальными переменными, пользуются кучей.

218.    С/С++. Оценить сколько раз можно погрузиться в рекурсию в конструкции void f(){f();} 

(*Осторожно, на сайте по-другому задан вопрос*)  
Многие компиляторы по умолчанию ставят размер стека, равный 1M. Функция void f(); кладет в стек текущий выполняемый адрес. Например, на 32-битной архитектуре это может занимать 4байта.  
Т.о. максимально возможная глубина рекурсии в этих предположениях = 1024*1024/4= 2 в 18 степени  

219.    C/C++. Ограничения на размер локальных автоматических переменных.  

(*Почти по аналогии с предыдущим вопросом*)  
Локальные переменные хранятся в стеке. Многие компиляторы по умолчанию ставят размер стека, равный 1M. Например переменная типа int (на большинстве машин) занимают 4 байта.  
Поэтому максимально возможное количество переменных типа int в нашем случае = 1024*1024/4= 2 в 18 степени

220.    Понятия процессов/нитей.

Процесс (задача) - программа, находящаяся в режиме выполнения.  
С каждым процессом связывается его адресное пространство, из которого он может читать и в которое он может писать данные.  
Каждому процессу соответствует адресное пространство и одиночный поток исполняемых команд. В многопользовательских системах, при каждом обращении к одному и тому же сервису, приходится создавать новый процесс для обслуживания клиента. Это менее выгодно, чем создать квазипараллельный поток внутри этого процесса с одним адресным пространством.  
С каждым потоком связывается:  
 Счетчик выполнения команд 
 Регистры для текущих переменных 
 Стек 
 Состояние
https://moodle.kstu.ru/mod/page/view.php?id=49 подробнее...  
Лично я бы добавила сюда рассказ про OMP и деление на параллельные секции, если нечего добавить, а говорить что-то нужно.

221.    С/С++. Как реализовать функцию, которая при первом вызове делает одно действие, а при последующих – другие.

Решается с помощью локальных статических переменных. Надо иметь в виду, что использование глобальных переменных – плохой тон. На самом деле, использование, вообще, статических переменных, это – всегда плохо (ну, например, статические переменные делают невозможным переход на использование написанных вами функций в многопоточной программе)
(*И более понятным языком*)
Для этого необходимо создать глобальную переменную вне функции, и при первом входе (*например с помощью условия, что она равна чему-либо*) изменить эту глобальную переменную  
Далее такого не будет происходить (*По крайней мере мы можем так сделать*)
222.    С/С++. Время жизни переменных.

223.    С/С++. Область видимости переменных.

224.    С/С++. Различие во времени рождения статических переменных.

225.    С/С++. Для каких массивов существует существенное ограничение на размер?

226.    C/C++. Что такое фактические и формальные параметры функций?

227.    С/С++. Кратко о механизмах передачи параметров в функции.

228.    С/С++. Что такое goto на уровне ассемблера?

229.    С/С++. Что такое вызов функции на уровне ассемблера?

230.    С/С++. Что такое switch на уровне ассемблера?   

switch(m){  
	case 2:  
	...	 
	case 3:  
	...  
	default:  
}  
Данная конструкция работает как "вычисляеммый goto"  
То есть на ассемблере выписывается весь код отвечающий разным значениям m  
Для каждого блока case может быть свое количество байт
switch (m) будет реализован как перейти на оператор, который имеет адрес по сравнению с текущим положением (на самом switch) текущий адрес - m +2 * размер 1 блока (*2 это case 2*)

231.    С. Как создать двумерный массив за одно отведение памяти?  

*m=(int**)malloc((strcount+1)int*+(count+strcount)int);  
//Это выделение памяти под косую матрицу
//нарезать указатели:  
(*m)[0]=(int*)((*m)+strcount+1);  
(*m)[1]=(*m)[0]+(*q);

## Вопросы по языку С.

1.    Арифметические операции. Оператор присваивания, как бинарный оператор, его значение.  

https://prog-cpp.ru/c-operation/  
https://ravesli.com/urok-39-arifmeticheskie-operatory/#toc-6

2.    В каком случае допустимо использование #include "mysuperlib.h"? В каком случае допустимо использование #include <mysuperlib.h>?  

https://arduinoplus.ru/include-v-cpp/  
https://ru.stackoverflow.com/questions/149/%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%B4%D0%B2%D1%83%D0%BC%D1%8F-%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D0%BC%D0%B8-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D1%8B-include-%D0%B2-%D0%BA%D0%B0%D0%B2%D1%8B%D1%87%D0%BA%D0%B0%D1%85-%D0%B8-%D0%B2-%D1%81%D0%BA%D0%BE%D0%B1%D0%BA%D0%B0%D1%85


3.    Директивы препроцессора: #define, #undef, #if..#else..#endif, #ifdef, #pragma once. Правила хорошего тона при оформлении оператора #define.  
http://cppstudio.com/post/5396/

4.    Директивы препроцессора: #include. Правила оформления (с помощью директив #ifdef/#define и #pragma once)  
http://cppstudio.com/post/5396/

5.    Для значений какого типа данных отводится 8 бит?  
char

6.    Какая комбинация знаков соответствует операции декрементирования?  
x--

7.    Какая комбинация знаков соответствует операции присваивания с суммированием?  
x+=

8.    Какие объекты передаются в функции в языке С по ссылке?  

Которые могут изменяться. Передача по ссылке позволяет возвратить из функции сразу несколько значений. Также передача параметров по ссылке является более эффективной при передаче очень больших объектов, поскольку в этом случае не происходит копирования значений, а функция использует сам объект, а не его значение. https://metanit.com/cpp/tutorial/3.3.php

9.    Какие способы передачи параметров в функции существуют в различных языках программирования?  

По значению и по ссылке(по адресу или указателю) https://studopedia.ru/10_237326_sposobi-peredachi-parametrov-funktsiyam.html

10.   Какое значение будет иметь переменная p после выполнения операций:
 int p=3, x=6;if ((p%x)>2) p=p+x;else { if (p%2==0) p=p-x; else p=-p-x; }  
ответ: x=6 b=9

11.   Какое значение будет иметь переменная p после выполнения операций: 
int p=3;switch (p<<1) { case 2: break;    case 3: p+=1; break;  case 4: p=p+2;  default: p=0; }  
ответ: 0

12.   Какое служебное слово используется для завершения текущей итерации цикла (продолжение цикла при помощи перехода к следующей итерации)?  
continue

13.   Какое служебное слово является заголовком оператора цикла с постусловием?  
do ... while 

14.   Какое служебное слово является заголовком оператора цикла с постусловием?  
do ... while (иногда repeat ... until)

15.   Какой знак соответствует операции остаток от деления целых чисел?
%

16.   Какой знак соответствует операции получения адреса операнда?  
&

17.   Какой знак соответствует операции получения остатка от деления целочисленных операндов?  
%

18.   Какой знак соответствует операции поразрядного инвертирования внутреннего двоичного кода целочисленного аргумента (побитовое отрицание)?  
~

19.   Какой синтаксис (функциональная схема) соответствует конструкции if-else?  

https://prog-cpp.ru/c-if/

20.   Какой синтаксис соответствует конструкции do-while?  

http://cppstudio.com/post/361/

21.   Какой тип данных имеет диапазон значений 0...+255?  

unsigned char

22.   Логические операции. Выражения, воспринимаемые как логические.  
в си по стандарту принято, что 0 - ложь, остальное - истина. целые числа можно рассматривать как истину(т.е выражение равное истине). double и float сравнивать с нулем не следует, но можно.  
пример: int x=0; if(x){...}  
https://spravochnick.ru/informatika/algebra_logiki_logika_kak_nauka/logicheskie_operacii_i_ih_svoystva/

23.   Математическая библиотека. Основные функции.  
http://cppstudio.com/post/413/

24.   Математическая библиотека. Правила использования функций pow().  
double pow(      double basis,      double exponent );  
long double pow( long double basis, long double exponent );  
float pow(       float basis,       float exponent );  
double pow(      double basis,         int exponent );

25.   Математическая библиотека. Различие функции pow() на С и С++.  
double pow(      double basis,      double exponent );  
long double pow( long double basis, long double exponent );  
float pow(       float basis,       float exponent );  
double pow(      double basis,         int exponent );  
включения: math.h для С, cmath для С++  
В C++, эта функция перегружена в заголовочных файлах <complex> и <valarray> (смотреть pow комплексных чисел и pow в библиотеке массивов числовых значений).

В Си, определена только версия  функции с типами данных её параметров, — double. Другие перегруженные версии этой функции есть только в C++.

26.   Может ли прототип double sign(double); являться прототипом функции с заголовком double sign(double k)?  
да

27.   Можно ли использовать "continue" внутри оператора switch?  
он будет относиться к внешнему циклу для switch, если таковой будет.
нет, не нужно так делать https://forum.sources.ru/index.php?showtopic=365058

28.   Можно ли использовать "return" внутри оператора switch?  
да, можно внутри к-л. функции, пример https://otvet.mail.ru/question/83768059

29.   Написать функцию, рекурсивно (!) определяющую является ли целое число N точной степенью двойки. Привести пример вызова такой функции.  
https://www.cyberforum.ru/cpp-beginners/thread1442053.html

30.   Что будет выведено на экран: {int x[5]; printf(”%d”,(int)sizeof(x));}  
8 - он же размер указателя

31.   Что будет выведено на экран при вызове функции: void f(int x[5]){ printf(”%d”,(int)sizeof(x));}  
20 = 4*5 

32.   Может ли синтаксически индекс массива быть отрицательным?  
да, например  int mass[]={1, 6, 9, 2, 5};int *mass2 = &mass[3];printf("%d", mass2[-1]);

33.   Напишите выводимое значение. int mass[]={1, 6, 9, 2, 5};int *mass2 = &mass[3];printf("%d", mass2[-1]);  
ответ: 9

34.   Напишите десятичное значение «-16» в прямом двоичном коде (ответ дать в 8битном представлении).  
1001 0000 //1 под минус и значение 

35.   Напишите десятичное значение «-16» в обратном двоичном коде (ответ дать в 8битном представлении).  
1110 1111 //1 под минус и инверсия  

36.   Напишите десятичное значение «-16» в дополнительном двоичном коде (ответ дать в 8битном представлении).   
1111 0000 //обратный +1

37.   Напишите значение выражения: (!1)+(!0)+(!(-5)).  
1110 + 1111 + !(1010)= 14+15+5= 34  
для си имеем 0+1+0=1

38.   Напишите значение выражения: (!18)-(5<<2)+(6^5).  
0 - (сдвиг вправо 101) + (искл. или 6 xor 5)=0-20+3=-17  
для си, !18 = 0. для номраьного ответа, нужно инвертировать:  
(!18)-(5<<2)+(6^5) = -19-20+3=-36

39.   Напишите значение выражения: (3==5)? 3 : 5.  
5

40.   Напишите значение выражения: (4<<2)|4;  
20

41.   Напишите значение выражения:  (6&5);  
4

42.   Напишите значение выражения:  (6^5);  
3

43.   Напишите значение выражения: (5<<1)+(3!=5)  
(5<<1)+(3!=5)) = 10+1=11   
11

44.   Напишите значение выражения: (7>>1)&4;  
6
  
45.   Напишите значение выражения: 3+4>5 && 3+5>4;  
1

46.   Напишите идентификатор, определяющий действия при отсутствии нужного варианта в операторе switch?  
default

47.   Напишите идентификатор, соответствующий операции определения размера операнда?  
sizeof

48.   Напишите название базового типа данных, который указывает на целое число увеличенной длины (длинное целое).  
long int

49.   Напишите название директивы макроподстановки.  
define

50.   Напишите название директивы препроцессора определения макроса или препроцессорного идентификатора.  
define

51.   Напишите название директивы препроцессора проверки неопределённости идентификатора.  
ifndef

52.   Напишите название квалификатора, который можно использовать с базовыми типами данных для установления «короткого» целого числа.  
short

53.   Напишите название квалификатора, который можно использовать с базовыми типами данных для установления значений со знаком.  
signed

54.   Напишите название оператора, который возвращает размер в байтах переменной или типа?  
sizeof()

55.   Напишите название функции арксинуса, принадлежащей математической библиотеке.  
asin

56.   Напишите название функции записи символа в файл.  
fprintf()

57.   Напишите название функции установки произвольной позиции в файле.  
fseek(f,pos,SEEK_SET);//курсор в позицию pos от начала файла  
lseek(int handle, int pos, int whence);  
https://studopedia.su/6_52978_ustanovka-proizvolnoy-pozitsii-v-fayle.html

58.   Напишите название функции форматированного чтения из файла.  
fscanf

59.   Напишите название функции форматированного чтения из строки.  
sscanf

60.   Напишите название функции, возвращающей значение натурального логарифма  
log(a)

61.   Напишите название функции, возвращающей значение первого числа в степени второго  
pow(a,b)

62.   Напишите название функции, возвращающей наибольшее целое, не превышающее данное значение.  
floor(x)

63.   Напишите название функции, выполняющей выделение памяти и перенос в неё копию заданной строки.  
strcpy

64.   Напишите название функции, выполняющей поиск второй заданной строки в первой.  
strstr  http://all-ht.ru/inf/prog/c/func/strstr.html

65.   Напишите название функции, выполняющей сравнение заданных строк.  
strcmp

66.   Напишите название функции, выполняющей сцепление строк символов.  
strcat

67.   Напишите название функции, вычисляющей ближайшее целое, не меньшее, чем данный вещественный аргумент  
ceil

68.   Напишите название функции, считывающей один символ из файла.  
fgetc

69.   Напишите название функции, считывающей очередной символ из стандартного входного потока (stdin).  
getc, getchar

70.   Напишите последовательность символов, выводимую при выполнении кода: 
… int main () {char str[] = "12345678910"; char * pch;pch=strchr(str,'5'); printf ("%s\n", pch);return 0;}  
ответ: 5678910

71.   Напишите последовательность символов, выводимую при выполнении кода: 
… int main(void) {char s1[80], s2[80];strcpy(s1, "A1"); strcpy(s2, "B2"); strcat(s1, s2);printf("%s", s1); return 0; }  
ответ: A1B2

72.   Напишите последовательность символов, выводимую при выполнении кода: … int main(void) {int a=27;char str[] = "12345678910";printf("%2s\n", str);return 0;}  
ответ: 12345678910

73.   Напишите последовательность символов, используемую внутри printf для выведения вывода вещественного числа в поле из 7 позиций.  
%7d   https://cpp.com.ru/shildt_spr_po_c/08/0804.html

74.   Напишите последовательность символов, используемую внутри printf для выведения двойных кавычек.  
printf("My text is: \"my text\"\n");

75.   Напишите последовательность символов, используемую внутри printf для выведения строки символов.  
%s

76.   Напишите последовательность символов, используемую внутри printf для выведения табуляции.  
\t

77.   Напишите последовательность символов, используемую внутри printf для выведения указателя.  
%p or %n

78.   Напишите последовательность символов, используемую внутри printf для выведения целого десятичного числа.  
%d или %i со знаком

79.   Напишите последовательность символов, используемую внутри printf для выведения числа в экспоненциальной форме.  
%e or %E

80.   Напишите последовательность символов, используемую внутри printf для выведения числа с двойной точностью.  
%2

81.   Напишите последовательность символов, используемую внутри printf для выведения шестнадцатеричного числа.  
%x or %X   (для формата 0xh.hhhhp+d можно использовать %а, %А)

82.   Напишите последовательность символов, используемую внутри printf для печати в выводимой строке не менее 15 символов.  
%.15s

83.   Что может содержаться в include-файлах и что в C-файлах.  

Цитата: в include-файле на одну функцию отводится только одна строка. Посему, либо функция короткая и ее определение в строку вмещается на экране, либо ее надо безжалостно выносить в с/cpp-файл.  
https://ru.stackoverflow.com/questions/275741/include-%D0%B2-%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D1%8B%D1%85-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0%D1%85

84.   Операторы перехода (break, continue, goto).    

http://cppprosto.blogspot.com/2017/09/break-continue-return-goto.html  

85.   Описать случаи, когда использование оператора goto является дурным тоном и когда оно необходимо.  

выйти из нескольких циклов сразу (или выйти из цикла и пропустить операцию) - необходимо, дурной тон - когда можно заменить на for.  
http://cppprosto.blogspot.com/2017/09/break-continue-return-goto.html  
https://habr.com/ru/post/114211/

86.   Операторы условия и выбора (if, switch). Синтаксис.  

https://prog-cpp.ru/c-if/  
https://habr.com/ru/post/347132/

87.   Оператор цикла for. Синтаксис.  

https://prog-cpp.ru/c-cycles/

88.   Оператор цикла  while. Синтаксис.  

https://prog-cpp.ru/c-cycles/

89.   Оператор цикла  do-while. Синтаксис.  

https://prog-cpp.ru/c-cycles/

90.   Операция ? : . Рекурсивное использование данного оператора.  

имеется в виду использование несколько раз, например:  
return x<0?0:x<10?1:x<100?2:3  
https://purecodecpp.com/archives/554  
https://inf5.ru/cpp_lections/lection_5.htm

91.   Опишите ситуацию, в которой sizeof(x) возвращает значение, отличное от 10, в случае если x описывается как char x[10].  

размер указателя, а не массива при передаче в функцию - он будет 8.  
https://ru.stackoverflow.com/questions/8574/%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-sizeof-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D1%82-%D0%BD%D0%B5-%D1%82%D0%BE-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5

92.   Основные скалярные типы (различные целые, вещественные).  

https://prog-cpp.ru/c-data-types/  

93.   Формат представления констант (различных целых, различных вещественных, символьных, строковых).  

https://prog-cpp.ru/c-data-types/  
https://rtfm.co.ua/books-translations/kurs-c-s-nulya/kurs-c-s-nulya-chast-5-konstanty/  
https://cpp.com.ru/shildt_spr_po_c/02/0209.html

94.   Почему при выполнении функции printf(“1”) на экране может ничего не появиться. Как исправить эту ситуацию?  

в си надо указать формат и подключить stdio. Также возможно не хватает fflush(stdout);    
http://citforum.ru/security/articles/printf/

95.   Работа с бинарными файлами. fopen/fclose/fread/fwrite.  

https://learnc.info/c/binary_files.html

96.   Работа с бинарными файлами. Использование функций fseek()/ftell()  

https://learnc.info/c/binary_files.html

97.   Работа с текстовыми файлами. Правила использования функции fgets().  

https://www.cyberforum.ru/cpp-beginners/thread389914.html  
https://learnc.info/c/text_files.html 

98.   Основные идеи считывание строк неограниченной длины с помощью функции fgets(). 

http://www.cplusplus.com/reference/cstdio/fgets/

99.   Стандартная библиотека ввода-вывода: семейство функций printf().  

https://cpp.com.ru/shildt_spr_po_c/08/0804.html   

100.    Основные спецификации формата в функциях типа printf().  

https://cpp.com.ru/shildt_spr_po_c/08/0804.html   

101.    Стандартная библиотека ввода-вывода: семейство функций scanf().Основные спецификации формата.  

https://cpp.com.ru/shildt_spr_po_c/13/scanf.html

102.     Стандартная библиотека ввода-вывода: семейство функций scanf(). Форматы %n и [] с примерами использования.  

https://cpp.com.ru/shildt_spr_po_c/13/scanf.html

103.    Строки в языке С, принципы организации.  

https://lektsii.org/9-33975.html

104.    Функции strlen, strcat, strcpy. В том числе, что они возвращают?  

https://lektsii.org/9-33975.html  
http://all-ht.ru/inf/prog/c/func

105.    Функции strdup,strcmp, strstr, strchr. В том числе, что они возвращают?  

https://lektsii.org/9-33975.html  
http://all-ht.ru/inf/prog/c/func

106.    Указатели и массивы. Указать в каких случаях их использование дает различный результат.  

под массив придется выделять память. Фиксированный массив знает свою длину, а указатель на массив — нет.
Еще различие возникает при использовании оператора адреса &. Используя адрес указателя, мы получаем адрес памяти переменной указателя. Используя адрес массива, возвращается указатель на целый массив.  
https://ravesli.com/urok-82-ukazateli-i-massivy/  
https://cpp.com.ru/kr_cbook/ch5kr.html

107.    Функции и прототипы, оператор return.  

https://cpp.com.ru/shildt_spr_po_c/06/0608.html 

108.    Объяснить логику компилятора, не позволяющего без описания определять функции перед использованием.  

препроцессор должен найти описание в include-файле (или в начале программы после других include) и вставить его содержимое на место include-файла. поэтому компилятор ищет в этом месте описание функции.
требование компилятора скорее не к описанию, а к существованию include-файла.
https://cpp.com.ru/shildt_spr_po_c/06/0608.html  
https://server.179.ru/tasks/cpp/total/105.html

109.    Чем отличается предназначение конструкции if-else от конструкции #if-#else-#endif?  

https://alexgyver.ru/lessons/conditions/#%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D1%8B-if-else

110.    Чем отличается функция printf от функции fprintf.  

fprintf записывает форматированный текст в указанный поток вывода.  
printf эквивалентно записи fprintf(stdout, ...) и записывает форматированный текст туда,куда указывает стандартный выходной поток.

111.    Как осуществить вывод на экран с помощью функции fprintf?  

fprintf( stdout, const char * format, ... );

112.    Чем является а в выражении double *a;?  

указателем https://learnc.info/c/pointers.html

113.    Что может являться прототипом функции func?:  

а) func(x); б) void func(double); в) double func(double x); г) int fun(double x);  
б,в. статья https://cpp.com.ru/shildt_spr_po_c/06/0608.html

114.    Что появится на экране при выполнении функции printf(“%d\n”,~-2);  

1

## Вопросы по языку Python.

1.    Как запустить программу на Python?

python3 prog.py

2.    Модель памяти Python  

Каждая переменная в Python действует как объект. Объекты могут быть простыми (содержащими числа, строки и т. д.) Или контейнерами (словарями, списками или пользовательскими классами). Важно: переменная в Python не хранит значение напрямую – она хранит лишь ссылку на объект.  
http://onreader.mdl.ru/MasteringConcurrencyInPython/content/Ch17.html  
https://webdevblog.ru/osnovy-upravleniya-pamyatju-v-python/

3.    Что хранится в памяти для каждой переменной в Python?  

Ссылку на объект. Каждая переменная в Python действует как объект. Объекты могут быть простыми (содержащими числа, строки и т. д.) Или контейнерами (словарями, списками или пользовательскими классами). Переменная в Python не хранит значение напрямую – она хранит лишь ссылку на объект.

4.    Что значит фраза a=b в Python?  

В данном примере Python не создает новый объект – он просто создает переменную a, которая ссылается на тот же объект, что и переменная b.

5.    Арифметические операции в Python.  

+ - * / % а также целочсленое деление // и возведение в степень **
http://pythonicway.com/python-operators

6.    Логические операции в Python  

словами and, or, not, in и битовые операции & | ^ ~ >> <<
http://pythonicway.com/python-operators

7.    Определение функций в Python  

def function(type1 a, type2 b, ...):  
https://pythonru.com/osnovy/funkcii-v-python

8.    Как задаются блоки в Python?  

табуляциями или одинаковым количеством пробелов

9.    Вывод на экран в Python. В том числе задание разделителей и вида завершения вывода функцией вывода.  

Примеры:  
print("A", "B", "C", sep="#")  
print("[1: " + str(1) + "]", end=" -- ")  
https://devpractice.ru/python-lesson-12-input-output-work-with-files/

10.   Открытие/закрытие файла  

myfile = open(имя-файла [, режим-доступа] [, буферизация])  
например, my_file = open("some.txt", "w")  
myfile.close();  
статья: http://pythonicway.com/python-fileio

11.   Вид оператора if…  

if test1:  
    state1  
elif test2:  
    state2  
else:  
    state3  

12.   Аналог оператора ?:  (из С) в Python.  

https://skobki.com/python-ternarnyj-uslovnyj-operator-if-or-else/   
пример:  
x, y = 25, 50  
big = x if x < y else y

13.   Исключения в Python. Пример.  

Обрабатываются конструкциями try, except, finally, raise.  
https://pythonru.com/osnovy/obrabotka-iskljuchenij-python-blok-try-except-blok-finally

14.   Подключение модулей на примере математического модуля. 

import math as m  
print(m.e)  
или так:  
from math import e, ceil as c  
print(c(4.6))   
print(e)  
https://pythonworld.ru/osnovy/rabota-s-modulyami-sozdanie-podklyuchenie-instrukciyami-import-i-from.html

15.   Оператор for  на примере разбиение строки на слова  

with open(fn, 'r') as f:  
 for word in [s for s1 in f for s2 in s1.split('\n') for s3 in s2.split('\t') for s4 in s3.split(',') for s in s4.split(' ') if s!='']:  
  try: ...  
  except ValueError: ...  

16.   Списки в Python. Функции добавления элемента в список/удаления элемента из списка.  

[]  
имеются функции list.append(x) 
list.extend(L) 
list.insert(i, x) 
list.remove(x) 
list.pop([i]) 
list.index(x, [start [, end]])
list.count(x) 
list.sort([key=функция]) 
list.reverse() 
list.copy() 
list.clear()  
https://pythonworld.ru/tipy-dannyx-v-python/spiski-list-funkcii-i-metody-spiskov.html

17.   Перебор элементов списка в Python  

for elem in list:
 print(elem)  
на всякий случай: https://webformyself.com/spiski-python-primery-comprehension-apend-sort-length-reverse/

18.   Сортировка в Python. Пример.  

values = [2, 10, 7, 14, 50]
//Чтобы отсортировать значения в порядке убывания:
values.sort(reverse = True)  
print(values)  
//Чтобы отсортировать значения в порядке возрастания:
values.sort()  
print(values)  
обычные сортировки (алгоритмы): https://webdevblog.ru/algoritmy-sortirovki-v-python/

19.   Лямбда-функции. Пример.  

Работают как шаблоны в С++. Хороший пример:  
f = lambda x: x * x  
print(f(5))  
https://pythonru.com/osnovy/vse-chto-nuzhno-znat-o-lambda-funkcijah-v-python  
https://pythonru.com/uroki/lambda-funcija-uroki-po-python-dlja-nachinajushhih

20.   Кортежи.  

()  
имеются функции как у списка, только без изменения элементов   
tuple.index(x, [start [, end]])
tuple.count(x) 
tuple.copy()  
https://pythonworld.ru/tipy-dannyx-v-python/kortezhi-tuple.html

21.   Словари  

{}  
имеют функции dict.clear() 
dict.copy() 
dict.fromkeys(seq[, value]) 
dict.get(key[, default]) 
dict.items() 
dict.keys() 
dict.pop(key[, default]) 
dict.popitem() 
dict.setdefault(key[, default]) 
dict.update([other]) 
dict.values() 
https://pythonru.com/osnovy/python-dict

22.   Использование кортежей в качестве индексов для словарей 

directory[last,first] = number  
//Внутри скобок выражение является кортежем.  
//Мы могли бы использовать присваивание кортежей в цикле 
for last, first in directory:  
 print first, last, directory[last, first]   
ссылка: https://webformyself.com/kortezhi-python-upakovka-raspakovka-sravnenie/  
Мой пример с Гауссом: 
 https://github.com/iamm3chanic/EVM/blob/master/semestr3/EXAM/z5/gauss.py
